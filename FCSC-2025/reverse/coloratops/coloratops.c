/* This file was generated by the Hex-Rays decompiler version 8.2.0.230124.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void sub_5588FFED9020();
void sub_5588FFED9036();
// float sinf(float x);
void sub_5588FFED9046();
void sub_5588FFED9056();
// __int64 __fastcall SDL_RenderCopy(__int64, __int64, __int64, __int64);
void sub_5588FFED9066();
// __int64 SDL_GetClipboardText(void); weak
void sub_5588FFED9086();
void sub_5588FFED9096();
void sub_5588FFED90A6();
void sub_5588FFED90B6();
void sub_5588FFED90C6();
// __int64 __fastcall SDL_PauseAudioDevice(_QWORD, _QWORD); weak
void sub_5588FFED90D6();
// void *memset(void *s, int c, size_t n);
void sub_5588FFED90E6();
// __int64 SDL_Quit(void); weak
void sub_5588FFED90F6();
// __int64 __fastcall SDL_FreeSurface(_QWORD); weak
void sub_5588FFED9106();
// __int64 __fastcall SDL_CreateRenderer(_QWORD, _QWORD, _QWORD); weak
void sub_5588FFED9116();
// size_t strlen(const char *s);
void sub_5588FFED9126();
// __int64 __fastcall SDL_CreateWindow(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
void sub_5588FFED9136();
void sub_5588FFED9146();
// struct SDL_Surface *__fastcall SDL_CreateRGBSurfaceWithFormat(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
void sub_5588FFED9156();
void sub_5588FFED9166();
void sub_5588FFED9176();
// int snprintf(char *s, size_t maxlen, const char *format, ...);
void sub_5588FFED9186();
// char *strchr(const char *s, int c);
void sub_5588FFED9196();
void sub_5588FFED91A6();
void sub_5588FFED91B6();
// __int64 __fastcall TTF_CloseFont(_QWORD); weak
void sub_5588FFED91C6();
// __int64 __fastcall SDL_DestroyWindow(_QWORD); weak
void sub_5588FFED91D6();
// struct SDL_Surface *__fastcall TTF_RenderText_Blended(_QWORD, _QWORD, _QWORD);
void sub_5588FFED91E6();
// __int64 __fastcall SDL_DestroyRenderer(_QWORD); weak
void sub_5588FFED91F6();
// __int64 SDL_StopTextInput(void); weak
void sub_5588FFED9206();
void sub_5588FFED9216();
// void __fastcall SDL_StartTextInput();
void sub_5588FFED9226();
void sub_5588FFED9236();
void sub_5588FFED9246();
// __int64 __fastcall SDL_RenderClear(_QWORD); weak
void sub_5588FFED9256();
// __int64 __fastcall SDL_CreateTextureFromSurface(_QWORD, _QWORD); weak
void sub_5588FFED9266();
void sub_5588FFED9276();
// __int64 __fastcall SDL_DestroyTexture(_QWORD); weak
void sub_5588FFED9286();
void sub_5588FFED9296();
void sub_5588FFED92A6();
// __int64 __fastcall SDL_OpenAudioDevice(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
void sub_5588FFED92B6();
void sub_5588FFED92C6();
// void *malloc(size_t size);
void sub_5588FFED92E6();
// __int64 __fastcall SDL_SetRenderDrawColor(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); weak
void sub_5588FFED92F6();
// __int64 __fastcall SDL_RenderPresent(_QWORD); weak
void sub_5588FFED9306();
void sub_5588FFED9316();
// void TTF_Init(void);
void sub_5588FFED9326();
// __int64 TTF_Quit(void); weak
void sub_5588FFED9336();
void sub_5588FFED9346();
void sub_5588FFED9356();
// __int64 __fastcall SDL_PollEvent(_QWORD); weak
void sub_5588FFED9366();
void sub_5588FFED9376();
// __int64 __fastcall SDL_GetTicks(_QWORD, _QWORD); weak
void sub_5588FFED9396();
void sub_5588FFED93A6();
// __int64 __fastcall SDL_free(_QWORD); weak
void sub_5588FFED93C6();
// __int64 __fastcall SDL_Init(_QWORD, _QWORD, _QWORD); weak
void sub_5588FFED93E6();
void sub_5588FFED93F6();
// __int64 __fastcall SDL_RenderReadPixels(_QWORD, struct SDL_Rect *, int, int, int);
void sub_5588FFED9406();
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void));
__int64 sub_5588FFED9480();
__int64 sub_5588FFED9500();
__int64 __fastcall sub_5588FFED9509(__int64 *a1, __int64 a2, int a3);
__int64 __fastcall sub_5588FFED953A(__int64 *a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall sub_5588FFED97C4(_QWORD); // weak
__int64 __fastcall sub_5588FFED97E2(__int64, char);
__int64 __fastcall sub_5588FFED9800(__int64 a1);
__int64 __fastcall sub_5588FFED9884(__int64 a1, unsigned __int16 a2, char a3);
__int64 __fastcall sub_5588FFED9912(__int64 a1);
__int64 __fastcall sub_5588FFED9936(__int64 a1);
__int64 __fastcall sub_5588FFED9995(__int64 a1, unsigned __int16 a2);
_WORD *__fastcall sub_5588FFED99CF(__int64 a1, _WORD *a2, _WORD *a3);
_BYTE *__fastcall sub_5588FFED9A14(__int64 a1, _BYTE *a2, _BYTE *a3, _BYTE *a4, _QWORD *a5);
__int64 __fastcall sub_5588FFED9B70(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_5588FFED9C11(_QWORD, _QWORD); // weak
__int64 __fastcall sub_5588FFED9C97(_QWORD); // weak
__int64 __fastcall sub_5588FFED9D20(unsigned __int8 *a1, unsigned __int64 a2);
__int64 __fastcall sub_5588FFEDA502(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, __int64 a4);
__m64 __fastcall sub_5588FFEDC203(int a1, char a2);
__int64 __fastcall sub_5588FFEDC362(_QWORD, _QWORD); // weak
__int64 __fastcall sub_5588FFEDC4A9(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_5588FFEDC531(__m128i a1, __int64 a2, __int64 a3, unsigned __int8 a4, char a5);
__int64 __fastcall sub_5588FFEDC5B5(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_5588FFEDC660(_QWORD, _QWORD); // weak
__int64 __fastcall sub_5588FFEDC7E7(_QWORD, _QWORD, double); // weak
__int64 __fastcall sub_5588FFEDC869(_QWORD, _QWORD); // weak
__int64 __fastcall sub_5588FFEDC95D(_QWORD, _QWORD); // weak
double __fastcall sub_5588FFEDCA51(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_5588FFEDCB2B(_QWORD); // weak
double __fastcall sub_5588FFEDCB65(double); // weak
double __fastcall sub_5588FFEDCB8D(double); // weak
double __fastcall sub_5588FFEDCBD3(double); // weak
double __fastcall sub_5588FFEDCD20(double); // weak
__m128i __fastcall sub_5588FFEDCD5D(__int64 a1, float a2);
__m128i __fastcall sub_5588FFEDCDB0(__int64 a1, __m128i a2, float a3);
__int64 __fastcall sub_5588FFEDD04C(__int64 a1, __int64 a2);
char __fastcall sub_5588FFEDD106(__int64 a1, __int64 a2, unsigned __int8 *a3, __m128i a4);
__int64 __fastcall sub_5588FFEDE0B4(__int64 a1, __int64 a2, char a3);
__int64 __fastcall sub_5588FFEDE283(_QWORD); // weak
__int64 __fastcall sub_5588FFEDE29B(_QWORD); // weak
__int64 __fastcall sub_5588FFEDE2E1(__int64 a1, __m128i a2);
float *__fastcall sub_5588FFEDE5D2(__int64 a1, __int64 a2, float *a3, float *a4, __m128i a5);
float *__fastcall sub_5588FFEDE7CE(__int64 a1, __m128i a2);
__int64 __fastcall sub_5588FFEDE8D5(__int64 a1, __m128i a2);
float __fastcall sub_5588FFEDF5E3(__int64 a1);
float *__fastcall sub_5588FFEDFD07(__int64 a1, float *a2, float *a3);
unsigned __int64 __fastcall sub_5588FFEE0138(__int64 a1, __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall sub_5588FFEE01C8(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_5588FFEE0298(_QWORD, _QWORD, _QWORD); // weak
__int64 __fastcall sub_5588FFEE0361(__int64 a1);
__int64 __fastcall decryptImage(__int64 renderer, _QWORD *a2, char *hash);
_BOOL8 __fastcall load_font(_QWORD *);
unsigned __int64 __fastcall find_integer_index(int);
__int64 checkCollours();
__int64 __fastcall hash_sha256(char *data, __int64 data_length, __int64 out);
void *__fastcall sub_5588FFEE0F01(__int64 a1, void *a2, int a3);
__int64 load_ressources();
int __cdecl main(int argc, const char **argv, const char **envp);
void term_proc();
// int __fastcall _libc_start_main(int (__fastcall *main)(int, char **, char **), int argc, char **ubp_av, void (*init)(void), void (*fini)(void), void (*rtld_fini)(void), void *stack_end);

//-------------------------------------------------------------------------
// Data declarations

_WORD word_5588FFEE2040[16] =
{
  1712,
  1616,
  1525,
  1440,
  1357,
  1281,
  1209,
  1141,
  1077,
  1017,
  961,
  907,
  856,
  0,
  0,
  0
}; // weak
float flt_5588FFEE2060[16] =
{
  0.0,
  -1.0,
  -2.0,
  -4.0,
  -8.0,
  -16.0,
  0.0,
  0.0,
  0.0,
  1.0,
  2.0,
  4.0,
  8.0,
  16.0,
  0.0,
  0.0
}; // weak
float flt_5588FFEE20A0[16] =
{
  1.0,
  1.0,
  1.0,
  1.0,
  1.0,
  1.0,
  0.66666669,
  0.5,
  1.0,
  1.0,
  1.0,
  1.0,
  1.0,
  1.0,
  1.5,
  2.0
}; // weak
_UNKNOWN unk_5588FFEE2400; // weak
struct SDL_Rect sdl_rect_1 = { 0, 0, 1200, 686 };
_DWORD dword_5588FFEE2420[64] =
{
  0,
  0,
  0,
  0,
  0,
  9,
  6,
  3,
  6,
  7,
  6,
  5,
  7,
  4,
  6,
  2,
  7,
  7,
  2,
  9,
  6,
  7,
  7,
  5,
  1,
  6,
  2,
  8,
  4,
  3,
  6,
  8,
  5,
  4,
  9,
  2,
  9,
  1,
  2,
  7,
  1,
  1,
  4,
  4,
  2,
  5,
  4,
  8,
  6,
  1,
  6,
  7,
  4,
  9,
  1,
  9,
  5,
  4,
  3,
  9,
  9,
  9,
  3,
  0
}; // weak
_DWORD dword_5588FFEE2520[10] =
{
  -1,
  -2144522241,
  -10920193,
  -7189249,
  -5356545,
  -3523841,
  -1966528769,
  1386640895,
  1783403519,
  428000511
}; // weak
int dword_5589001421A4 = 24492; // weak
__int64 window; // weak
_QWORD renderer; // idb
__int64 enter_pw_umgae; // weak
__int64 final_render; // weak
__int64 qword_558900142200; // weak
_QWORD font; // idb
int dword_558900142210; // weak
_UNKNOWN unk_558900142220; // weak
__int16 word_558900142224; // weak
__int64 qword_558900142240; // weak
__int64 sound_image1; // weak
__int64 sound_image2; // weak
char user_input[]; // weak
__int64 user_input_length; // weak
int dword_558900142368; // weak
int counter_finished; // weak
int ticks; // weak
int dword_558900142374; // weak


//----- (00005588FFED9000) ----------------------------------------------------
__int64 init_proc()
{
  return 0LL;
}
// 5588FFED9000: using guessed type __int64 __fastcall init_proc();
// 558900142588: using guessed type __int64 _gmon_start__(void);

//----- (00005588FFED9020) ----------------------------------------------------
void sub_564317C09020()
{
  JUMPOUT(0x7FA791006240LL);
}
// 5588FFED9026: control flows out of bounds to 7FA791006240

//----- (00005588FFED9036) ----------------------------------------------------
void sub_5588FFED9036()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9046) ----------------------------------------------------
void sub_5588FFED9046()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9056) ----------------------------------------------------
void sub_5588FFED9056()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9066) ----------------------------------------------------
void sub_5588FFED9066()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9076) ----------------------------------------------------
__int64 sub_564317C09076()
{
  return sub_5588FFED9020();
}
// 5588FFED9020: using guessed type __int64 sub_564317C09020(void);

//----- (00005588FFED9086) ----------------------------------------------------
void sub_5588FFED9086()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9096) ----------------------------------------------------
void sub_5588FFED9096()
{
  sub_5588FFED9020();
}

//----- (00005588FFED90A6) ----------------------------------------------------
void sub_5588FFED90A6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED90B6) ----------------------------------------------------
void sub_5588FFED90B6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED90C6) ----------------------------------------------------
void sub_5588FFED90C6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED90D6) ----------------------------------------------------
void sub_5588FFED90D6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED90E6) ----------------------------------------------------
void sub_5588FFED90E6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED90F6) ----------------------------------------------------
void sub_5588FFED90F6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9106) ----------------------------------------------------
void sub_5588FFED9106()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9116) ----------------------------------------------------
void sub_5588FFED9116()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9126) ----------------------------------------------------
void sub_5588FFED9126()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9136) ----------------------------------------------------
void sub_5588FFED9136()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9146) ----------------------------------------------------
void sub_5588FFED9146()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9156) ----------------------------------------------------
void sub_5588FFED9156()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9166) ----------------------------------------------------
void sub_5588FFED9166()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9176) ----------------------------------------------------
void sub_5588FFED9176()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9186) ----------------------------------------------------
void sub_5588FFED9186()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9196) ----------------------------------------------------
void sub_5588FFED9196()
{
  sub_5588FFED9020();
}

//----- (00005588FFED91A6) ----------------------------------------------------
void sub_5588FFED91A6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED91B6) ----------------------------------------------------
void sub_5588FFED91B6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED91C6) ----------------------------------------------------
void sub_5588FFED91C6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED91D6) ----------------------------------------------------
void sub_5588FFED91D6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED91E6) ----------------------------------------------------
void sub_5588FFED91E6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED91F6) ----------------------------------------------------
void sub_5588FFED91F6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9206) ----------------------------------------------------
void sub_5588FFED9206()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9216) ----------------------------------------------------
void sub_5588FFED9216()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9226) ----------------------------------------------------
void sub_5588FFED9226()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9236) ----------------------------------------------------
void sub_5588FFED9236()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9246) ----------------------------------------------------
void sub_5588FFED9246()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9256) ----------------------------------------------------
void sub_5588FFED9256()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9266) ----------------------------------------------------
void sub_5588FFED9266()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9276) ----------------------------------------------------
void sub_5588FFED9276()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9286) ----------------------------------------------------
void sub_5588FFED9286()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9296) ----------------------------------------------------
void sub_5588FFED9296()
{
  sub_5588FFED9020();
}

//----- (00005588FFED92A6) ----------------------------------------------------
void sub_5588FFED92A6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED92B6) ----------------------------------------------------
void sub_5588FFED92B6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED92C6) ----------------------------------------------------
void sub_5588FFED92C6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED92D6) ----------------------------------------------------
void sub_564317C092D6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED92E6) ----------------------------------------------------
void sub_5588FFED92E6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED92F6) ----------------------------------------------------
void sub_5588FFED92F6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9306) ----------------------------------------------------
void sub_5588FFED9306()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9316) ----------------------------------------------------
void sub_5588FFED9316()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9326) ----------------------------------------------------
void sub_5588FFED9326()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9336) ----------------------------------------------------
void sub_5588FFED9336()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9346) ----------------------------------------------------
void sub_5588FFED9346()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9356) ----------------------------------------------------
void sub_5588FFED9356()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9366) ----------------------------------------------------
void sub_5588FFED9366()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9376) ----------------------------------------------------
void sub_5588FFED9376()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9386) ----------------------------------------------------
void sub_564317C09386()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9396) ----------------------------------------------------
void sub_5588FFED9396()
{
  sub_5588FFED9020();
}

//----- (00005588FFED93A6) ----------------------------------------------------
void sub_5588FFED93A6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED93B6) ----------------------------------------------------
void sub_564317C093B6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED93C6) ----------------------------------------------------
void sub_5588FFED93C6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED93D6) ----------------------------------------------------
void sub_564317C093D6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED93E6) ----------------------------------------------------
void sub_5588FFED93E6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED93F6) ----------------------------------------------------
void sub_5588FFED93F6()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9406) ----------------------------------------------------
void sub_5588FFED9406()
{
  sub_5588FFED9020();
}

//----- (00005588FFED9420) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)(void))
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (__fastcall *)(int, char **, char **))main, v4, &retaddr, 0LL, 0LL, a3, &v5);
  __halt();
}
// 5588FFED9426: positive sp value 8 has been found
// 5588FFED942D: variable 'v3' is possibly undefined

//----- (00005588FFED9450) ----------------------------------------------------
void *sub_564317C09450()
{
  return &edata;
}

//----- (00005588FFED9480) ----------------------------------------------------
__int64 sub_5588FFED9480()
{
  return 0LL;
}

//----- (00005588FFED94C0) ----------------------------------------------------
__int64 sub_564317C094C0()
{
  __int64 result; // rax

  if ( !byte_5589001421C8 )
  {
    if ( &MEMORY[0x7EED7892CF40] )
      _cxa_finalize(off_5588FFEE5208);
    result = sub_5588FFED9450();
    byte_5589001421C8 = 1;
  }
  return result;
}
// 5588FFED9450: using guessed type __int64 sub_564317C09450(void);
// 5588FFED94C0: using guessed type __int64 __fastcall sub_564317C094C0();
// 5589001421C8: using guessed type char byte_564317E721C8;

//----- (00005588FFED9500) ----------------------------------------------------
// attributes: thunk
__int64 sub_5588FFED9500()
{
  return sub_5588FFED9480();
}

//----- (00005588FFED9509) ----------------------------------------------------
__int64 __fastcall sub_5588FFED9509(__int64 *a1, __int64 a2, int a3)
{
  return sub_5588FFED953A(a1, a2, -1LL, a3);
}

//----- (00005588FFED953A) ----------------------------------------------------
__int64 __fastcall sub_558FFED3E53A(__int64 *a1, __int64 a2, __int64 a3, int a4)
{
  __int64 v5; // rax
  __int64 v8; // [rsp+28h] [rbp-28h]
  __int64 v9; // [rsp+30h] [rbp-20h]
  char *s; // [rsp+38h] [rbp-18h]
  void *sa; // [rsp+38h] [rbp-18h]
  __int64 size; // [rsp+40h] [rbp-10h]
  unsigned __int8 i; // [rsp+4Fh] [rbp-1h]

  if ( (unsigned int)sub_5588FFED9C11(a2, a3) )
    return 1LL;
  size = sub_5588FFED9D20(a2, a3);
  s = (char *)malloc(size);
  if ( !s && size )
    return 2LL;
  memset(s, 0, size);
  *a1 = (__int64)s;
  v9 = *a1;
  *(_QWORD *)v9 = s;
  *(_DWORD *)(v9 + 336) = a4;
  v5 = sub_5588FFEDA502(v9, a2, a3, s + 408);
  *(_QWORD *)(v9 + 400) = v5;
  sa = (void *)(312LL * *(unsigned __int16 *)(v9 + 54) + v5);
  *(_DWORD *)(v9 + 344) = 1065353216;
  *(_DWORD *)(v9 + 348) = 1048576000;
  *(_DWORD *)(v9 + 352) = 1006632960;
  *(_DWORD *)(v9 + 356) = 1006632960;
  for ( i = 0; i < (unsigned int)*(_WORD *)(v9 + 54); ++i )
  {
    v8 = *(_QWORD *)(v9 + 400) + 312LL * i;
    *(_BYTE *)(v8 + 48) = 1;
    *(_DWORD *)(v8 + 112) = 0;
    *(_BYTE *)(v8 + 116) = 1;
    *(_DWORD *)(v8 + 124) = 0;
    *(_BYTE *)(v8 + 128) = 1;
    *(_DWORD *)(v8 + 64) = 1065353216;
    *(_DWORD *)(v8 + 68) = *(_DWORD *)(v8 + 64);
    *(_DWORD *)(v8 + 52) = *(_DWORD *)(v8 + 68);
    *(_DWORD *)(v8 + 72) = 1056964608;
    *(_DWORD *)(v8 + 56) = *(_DWORD *)(v8 + 72);
    *(_DWORD *)(v8 + 308) = 0;
    *(_DWORD *)(v8 + 304) = 1056964608;
  }
  *(_QWORD *)(v9 + 384) = sa;
  if ( !(unsigned int)sub_5588FFED9C97(v9) )
    return 0LL;
  sub_5588FFED97C4(v9);
  return 1LL;
}
// 5588FFED97C4: using guessed type __int64 __fastcall sub_558FFED3E7C4(_QWORD);
// 5588FFED9C11: using guessed type __int64 __fastcall sub_558FFED3EC11(_QWORD, _QWORD);
// 5588FFED9C97: using guessed type __int64 __fastcall sub_558FFED3EC97(_QWORD);
// 5588FFED9D20: using guessed type __int64 __fastcall sub_558FFED3ED20(_QWORD, _QWORD);
// 5588FFEDA502: using guessed type __int64 __fastcall sub_558FFED3F502(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00005588FFED97C4) ----------------------------------------------------
void __fastcall sub_564317C097C4(void **a1)
{
  free(*a1);
}

//----- (00005588FFED97E2) ----------------------------------------------------
__int64 __fastcall sub_55F292A7F7E2(__int64 a1, char a2)
{
  __int64 result; // rax

  result = a1;
  *(_BYTE *)(a1 + 393) = a2;
  return result;
}

//----- (00005588FFED9800) ----------------------------------------------------
__int64 __fastcall sub_5588FFED9800(__int64 a1)
{
  return *(unsigned __int8 *)(a1 + 392);
}

//----- (00005588FFED9815) ----------------------------------------------------
__int64 __fastcall sub_564317C09815(__int64 a1, unsigned __int16 a2, char a3)
{
  unsigned __int8 v4; // [rsp+1Fh] [rbp-1h]

  v4 = *(_BYTE *)(312LL * a2 - 312 + *(_QWORD *)(a1 + 400) + 152);
  *(_BYTE *)(*(_QWORD *)(a1 + 400) + 312LL * a2 - 312 + 152) = a3;
  return v4;
}

//----- (00005588FFED9884) ----------------------------------------------------
__int64 __fastcall sub_558FFED3E884(__int64 a1, unsigned __int16 a2, char a3)
{
  unsigned __int8 v4; // [rsp+1Fh] [rbp-1h]

  v4 = *(_BYTE *)(*(_QWORD *)(a1 + 328) + 272LL * a2 - 272 + 256);
  *(_BYTE *)(*(_QWORD *)(a1 + 328) + 272LL * a2 - 272 + 256) = a3;
  return v4;
}

//----- (00005588FFED9900) ----------------------------------------------------
__int64 __fastcall sub_564317C09900(__int64 a1)
{
  return a1 + 8;
}

//----- (00005588FFED9912) ----------------------------------------------------
__int64 __fastcall sub_5588FFED9912(__int64 a1)
{
  return a1 + 29;
}

//----- (00005588FFED9924) ----------------------------------------------------
__int64 __fastcall sub_564317C09924(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 54);
}

//----- (00005588FFED9936) ----------------------------------------------------
__int64 __fastcall sub_558FFED3E936(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 50);
}

//----- (00005588FFED9948) ----------------------------------------------------
__int64 __fastcall sub_564317C09948(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 56);
}

//----- (00005588FFED995A) ----------------------------------------------------
__int64 __fastcall sub_564317C0995A(__int64 a1, unsigned __int16 a2)
{
  return *(unsigned __int16 *)(16LL * a2 + *(_QWORD *)(a1 + 320));
}

//----- (00005588FFED9983) ----------------------------------------------------
__int64 __fastcall sub_564317C09983(__int64 a1)
{
  return *(unsigned __int16 *)(a1 + 58);
}

//----- (00005588FFED9995) ----------------------------------------------------
__int64 __fastcall sub_558FFED3E995(__int64 a1, unsigned __int16 a2)
{
  return *(unsigned __int16 *)(*(_QWORD *)(a1 + 328) + 272LL * a2 - 272 + 24);
}

//----- (00005588FFED99CF) ----------------------------------------------------
_WORD *__fastcall sub_5588FFED99CF(__int64 a1, _WORD *a2, _WORD *a3)
{
  _WORD *result; // rax

  if ( a2 )
  {
    result = a2;
    *a2 = *(_WORD *)(a1 + 342);
  }
  if ( a3 )
  {
    result = a3;
    *a3 = *(_WORD *)(a1 + 340);
  }
  return result;
}

//----- (00005588FFED9A14) ----------------------------------------------------
_BYTE *__fastcall sub_558FFED3EA14(__int64 a1, _BYTE *a2, _BYTE *a3, _BYTE *a4, _QWORD *a5)
{
  _BYTE *result; // rax

  if ( a2 )
  {
    result = a2;
    *a2 = *(_BYTE *)(a1 + 360);
  }
  if ( a3 )
  {
    result = a3;
    *a3 = *(_BYTE *)(a1 + *(unsigned __int8 *)(a1 + 360) + 64);
  }
  if ( a4 )
  {
    result = a4;
    *a4 = *(_BYTE *)(a1 + 361);
  }
  if ( a5 )
  {
    result = a5;
    *a5 = *(_QWORD *)(a1 + 368);
  }
  return result;
}

//----- (00005588FFED9A9E) ----------------------------------------------------
__int64 __fastcall sub_564317C09A9E(__int64 a1, unsigned __int16 a2)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 328) + 272LL * a2 - 272 + 248);
}

//----- (00005588FFED9ADB) ----------------------------------------------------
__int64 __fastcall sub_564317C09ADB(__int64 a1, unsigned __int16 a2, unsigned __int16 a3)
{
  return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 328) + 272LL * a2 - 272 + 264) + 80LL * a3 + 64);
}

//----- (00005588FFED9B39) ----------------------------------------------------
__int64 __fastcall sub_564317C09B39(__int64 a1, unsigned __int16 a2)
{
  return *(_QWORD *)(312LL * a2 - 312 + *(_QWORD *)(a1 + 400) + 144);
}

//----- (00005588FFED9B70) ----------------------------------------------------
void *__fastcall sub_564317C09B70(char *a1, size_t a2, __int64 a3, unsigned __int64 a4, unsigned __int64 a5)
{
  size_t v5; // rax
  size_t v6; // rdx
  size_t v7; // rax
  size_t n; // [rsp+38h] [rbp-18h]

  if ( a4 < a5 )
    v5 = 0LL;
  else
    v5 = a4 - a5;
  v6 = v5;
  v7 = a2;
  if ( v6 <= a2 )
    v7 = v6;
  n = v7;
  memcpy(a1, (const void *)(a3 + a5), v7);
  return memset(&a1[n], 0, a2 - n);
}

//----- (00005588FFED9C11) ----------------------------------------------------
__int64 __fastcall sub_564317C09C11(_BYTE *a1, unsigned __int64 a2)
{
  if ( a2 <= 0x3B )
    return 4LL;
  if ( memcmp("Extended Module: ", a1, 0x11uLL) )
    return 1LL;
  if ( a1[37] != 26 )
    return 2LL;
  if ( a1[59] == 1 && a1[58] == 4 )
    return 0LL;
  return 3LL;
}

//----- (00005588FFED9C97) ----------------------------------------------------
__int64 __fastcall sub_564317C09C97(__int64 a1)
{
  unsigned __int8 i; // [rsp+17h] [rbp-1h]

  for ( i = 0; i < (unsigned int)*(_WORD *)(a1 + 50); ++i )
  {
    if ( *(unsigned __int8 *)(a1 + i + 64) >= (unsigned int)*(_WORD *)(a1 + 56) )
    {
      if ( i + 1 != *(unsigned __int16 *)(a1 + 50) || *(_WORD *)(a1 + 50) <= 1u )
        return 1LL;
      --*(_WORD *)(a1 + 50);
    }
  }
  return 0LL;
}

//----- (00005588FFED9D20) ----------------------------------------------------
__int64 __fastcall sub_5588FFED9D20(unsigned __int8 *a1, unsigned __int64 a2)
{
  __int16 v2; // cx
  __int16 v3; // ax
  __int16 v4; // cx
  __int16 v5; // ax
  __int16 v6; // cx
  __int16 v7; // ax
  int v8; // eax
  int v9; // edx
  int v10; // eax
  int v11; // edx
  int v12; // esi
  unsigned int v13; // eax
  int v14; // edx
  __int16 v15; // cx
  __int16 v16; // ax
  int v17; // eax
  int v18; // edx
  int v19; // esi
  int v20; // eax
  int v21; // edx
  int v22; // ecx
  unsigned int v23; // eax
  int v24; // edx
  unsigned __int16 v25; // cx
  unsigned __int16 v26; // ax
  int v27; // eax
  int v28; // edx
  int v29; // esi
  int v30; // eax
  int v31; // edx
  int v32; // eax
  int v33; // edx
  int v34; // esi
  unsigned int v35; // eax
  int v36; // edx
  int v37; // eax
  int v38; // edx
  int v39; // esi
  int v40; // eax
  int v41; // edx
  unsigned __int8 v42; // al
  __int64 v43; // rax
  unsigned int v46; // [rsp+14h] [rbp-2Ch]
  unsigned __int16 v47; // [rsp+1Ah] [rbp-26h]
  unsigned __int16 v48; // [rsp+1Ch] [rbp-24h]
  unsigned __int16 v49; // [rsp+1Eh] [rbp-22h]
  unsigned __int16 v50; // [rsp+20h] [rbp-20h]
  unsigned __int16 k; // [rsp+22h] [rbp-1Eh]
  unsigned int v52; // [rsp+24h] [rbp-1Ch]
  unsigned int v53; // [rsp+28h] [rbp-18h]
  unsigned __int16 j; // [rsp+2Ch] [rbp-14h]
  unsigned __int16 i; // [rsp+2Eh] [rbp-12h]
  unsigned __int64 v56; // [rsp+30h] [rbp-10h]
  unsigned __int64 v57; // [rsp+30h] [rbp-10h]
  __int64 v58; // [rsp+38h] [rbp-8h]
  __int64 v59; // [rsp+38h] [rbp-8h]
  __int64 v60; // [rsp+38h] [rbp-8h]

  if ( a2 <= 0x44 )
    v2 = 0;
  else
    v2 = a1[68];
  if ( a2 <= 0x45 )
    v3 = 0;
  else
    v3 = a1[69] << 8;
  v50 = v2 | v3;
  if ( a2 <= 0x46 )
    v4 = 0;
  else
    v4 = a1[70];
  if ( a2 <= 0x47 )
    v5 = 0;
  else
    v5 = a1[71] << 8;
  v49 = v4 | v5;
  v58 = 16LL * (unsigned __int16)(v4 | v5);
  if ( a2 <= 0x48 )
    v6 = 0;
  else
    v6 = a1[72];
  if ( a2 <= 0x49 )
    v7 = 0;
  else
    v7 = a1[73] << 8;
  v48 = v6 | v7;
  v59 = 272LL * (unsigned __int16)(v6 | v7) + v58;
  if ( a2 <= 0x40 )
    v8 = 0;
  else
    v8 = a1[64];
  if ( a2 <= 0x41 )
    v9 = 0;
  else
    v9 = a1[65] << 8;
  v60 = ((v9 | v8) << 8) + v59;
  if ( a2 <= 0x3C )
    v10 = 0;
  else
    v10 = a1[60];
  if ( a2 <= 0x3D )
    v11 = 0;
  else
    v11 = a1[61] << 8;
  v12 = v11 | v10;
  if ( a2 <= 0x3E )
    v13 = 0;
  else
    v13 = a1[62];
  if ( a2 <= 0x3F )
    v14 = 0;
  else
    v14 = a1[63] << 8;
  v56 = (v12 | ((v14 | v13) << 16)) + 60LL;
  for ( i = 0; i < v49; ++i )
  {
    if ( v56 + 5 >= a2 )
      v15 = 0;
    else
      v15 = a1[v56 + 5];
    if ( v56 + 6 >= a2 )
      v16 = 0;
    else
      v16 = a1[v56 + 6] << 8;
    v60 += 5LL * (unsigned __int16)(v15 | v16) * v50;
    if ( v56 >= a2 )
      v17 = 0;
    else
      v17 = a1[v56];
    if ( v56 + 1 >= a2 )
      v18 = 0;
    else
      v18 = a1[v56 + 1] << 8;
    v19 = v18 | v17;
    if ( v56 + 2 >= a2 )
      v20 = 0;
    else
      v20 = a1[v56 + 2];
    if ( v56 + 3 >= a2 )
      v21 = 0;
    else
      v21 = a1[v56 + 3] << 8;
    v22 = ((v21 | v20) << 16) | v19;
    if ( v56 + 7 >= a2 )
      v23 = 0;
    else
      v23 = a1[v56 + 7];
    if ( v56 + 8 >= a2 )
      v24 = 0;
    else
      v24 = a1[v56 + 8] << 8;
    v56 += v22 + (v24 | v23);
  }
  for ( j = 0; j < v48; ++j )
  {
    v53 = 0;
    v52 = 0;
    if ( v56 + 27 >= a2 )
      v25 = 0;
    else
      v25 = a1[v56 + 27];
    if ( v56 + 28 >= a2 )
      v26 = 0;
    else
      v26 = a1[v56 + 28] << 8;
    v47 = v25 | v26;
    v60 += 80LL * (unsigned __int16)(v25 | v26);
    if ( v25 | v26 )
    {
      if ( v56 + 29 >= a2 )
        v27 = 0;
      else
        v27 = a1[v56 + 29];
      if ( v56 + 30 >= a2 )
        v28 = 0;
      else
        v28 = a1[v56 + 30] << 8;
      v29 = v28 | v27;
      if ( v56 + 31 >= a2 )
        v30 = 0;
      else
        v30 = a1[v56 + 31];
      if ( v56 + 32 >= a2 )
        v31 = 0;
      else
        v31 = a1[v56 + 32] << 8;
      v53 = v29 | ((v31 | v30) << 16);
    }
    if ( v56 >= a2 )
      v32 = 0;
    else
      v32 = a1[v56];
    if ( v56 + 1 >= a2 )
      v33 = 0;
    else
      v33 = a1[v56 + 1] << 8;
    v34 = v33 | v32;
    if ( v56 + 2 >= a2 )
      v35 = 0;
    else
      v35 = a1[v56 + 2];
    if ( v56 + 3 >= a2 )
      v36 = 0;
    else
      v36 = a1[v56 + 3] << 8;
    v57 = (v34 | ((v36 | v35) << 16)) + v56;
    for ( k = 0; k < v47; ++k )
    {
      if ( v57 >= a2 )
        v37 = 0;
      else
        v37 = a1[v57];
      if ( v57 + 1 >= a2 )
        v38 = 0;
      else
        v38 = a1[v57 + 1] << 8;
      v39 = v38 | v37;
      if ( v57 + 2 >= a2 )
        v40 = 0;
      else
        v40 = a1[v57 + 2];
      if ( v57 + 3 >= a2 )
        v41 = 0;
      else
        v41 = a1[v57 + 3] << 8;
      v46 = v39 | ((v41 | v40) << 16);
      if ( v57 + 14 >= a2 )
        v42 = 0;
      else
        v42 = a1[v57 + 14];
      v52 += v46;
      if ( (v42 & 0x10) != 0 )
        v43 = 2LL * v46;
      else
        v43 = 4LL * v46;
      v60 += v43;
      v57 += v53;
    }
    v56 = v52 + v57;
  }
  return 312LL * v50 + v60 + 408;
}

//----- (00005588FFEDA502) ----------------------------------------------------
__int64 __fastcall sub_5588FFEDA502(__int64 a1, unsigned __int8 *a2, unsigned __int64 a3, __int64 a4)
{
  int v4; // eax
  int v5; // edx
  int v6; // esi
  int v7; // eax
  int v8; // edx
  __int16 v9; // cx
  __int16 v10; // ax
  __int16 v11; // cx
  __int16 v12; // ax
  __int16 v13; // cx
  __int16 v14; // ax
  __int16 v15; // cx
  __int16 v16; // ax
  __int16 v17; // cx
  __int16 v18; // ax
  unsigned __int8 v19; // cl
  __int16 v20; // cx
  __int16 v21; // ax
  __int16 v22; // cx
  __int16 v23; // ax
  __int16 v24; // cx
  __int16 v25; // ax
  __int16 v26; // cx
  __int16 v27; // ax
  int v28; // eax
  int v29; // edx
  int v30; // esi
  unsigned int v31; // eax
  int v32; // edx
  char v33; // al
  unsigned __int8 v34; // al
  unsigned __int8 v35; // al
  unsigned __int8 v36; // al
  unsigned __int8 v37; // al
  unsigned __int8 v38; // al
  unsigned __int8 v39; // al
  unsigned __int8 v40; // al
  unsigned __int8 v41; // al
  unsigned __int8 v42; // al
  __int16 v43; // cx
  __int16 v44; // ax
  int v45; // eax
  int v46; // edx
  int v47; // esi
  int v48; // eax
  int v49; // edx
  unsigned __int8 v50; // al
  unsigned __int8 v51; // al
  __int16 v52; // cx
  __int16 v53; // ax
  __int16 v54; // cx
  __int16 v55; // ax
  __int16 v56; // cx
  __int16 v57; // ax
  __int16 v58; // cx
  __int16 v59; // ax
  unsigned __int8 v60; // al
  unsigned __int8 v61; // al
  unsigned __int8 v62; // al
  unsigned __int8 v63; // al
  unsigned __int8 v64; // al
  unsigned __int8 v65; // al
  unsigned __int8 v66; // al
  unsigned __int8 v67; // al
  int v68; // eax
  unsigned __int8 v69; // al
  unsigned __int8 v70; // al
  unsigned __int8 v71; // al
  __int16 v72; // cx
  __int16 v73; // ax
  int v74; // eax
  int v75; // edx
  int v76; // esi
  unsigned int v77; // eax
  int v78; // edx
  int v79; // eax
  int v80; // edx
  int v81; // esi
  int v82; // eax
  int v83; // edx
  int v84; // eax
  int v85; // edx
  int v86; // esi
  int v87; // eax
  int v88; // edx
  int v89; // eax
  int v90; // edx
  int v91; // esi
  int v92; // eax
  int v93; // edx
  float v94; // xmm0_4
  unsigned __int8 v95; // dl
  unsigned __int8 v96; // al
  char v97; // dl
  float v98; // xmm0_4
  unsigned __int8 v99; // dl
  __int16 v100; // cx
  __int16 v101; // ax
  unsigned __int8 v102; // al
  __int64 v105; // [rsp+0h] [rbp-A0h]
  __int64 v106; // [rsp+0h] [rbp-A0h]
  _BYTE *v109; // [rsp+20h] [rbp-80h]
  char v110; // [rsp+2Fh] [rbp-71h]
  unsigned __int16 *v111; // [rsp+30h] [rbp-70h]
  unsigned __int16 v112; // [rsp+3Ch] [rbp-64h]
  __int64 v113; // [rsp+40h] [rbp-60h]
  unsigned int v114; // [rsp+4Ch] [rbp-54h]
  __int64 v115; // [rsp+50h] [rbp-50h]
  __int64 v116; // [rsp+60h] [rbp-40h]
  unsigned int v117; // [rsp+6Ch] [rbp-34h]
  unsigned int kk; // [rsp+78h] [rbp-28h]
  char v119; // [rsp+7Fh] [rbp-21h]
  unsigned int jj; // [rsp+80h] [rbp-20h]
  __int16 v121; // [rsp+84h] [rbp-1Ch]
  unsigned __int16 ii; // [rsp+86h] [rbp-1Ah]
  unsigned __int16 n; // [rsp+88h] [rbp-18h]
  unsigned __int8 m; // [rsp+8Ah] [rbp-16h]
  unsigned __int8 k; // [rsp+8Bh] [rbp-15h]
  unsigned int v126; // [rsp+8Ch] [rbp-14h]
  unsigned __int16 j; // [rsp+90h] [rbp-10h]
  unsigned __int16 v128; // [rsp+92h] [rbp-Eh]
  unsigned __int16 v129; // [rsp+94h] [rbp-Ch]
  unsigned __int16 i; // [rsp+96h] [rbp-Ah]
  unsigned __int64 v131; // [rsp+98h] [rbp-8h]
  unsigned __int64 v132; // [rsp+98h] [rbp-8h]

  sub_5588FFED9B70(a1 + 8, 20LL, a2, a3, 17LL);
  sub_5588FFED9B70(a1 + 29, 20LL, a2, a3, 38LL);
  if ( a3 <= 0x3C )
    v4 = 0;
  else
    v4 = a2[60];
  if ( a3 <= 0x3D )
    v5 = 0;
  else
    v5 = a2[61] << 8;
  v6 = v5 | v4;
  if ( a3 <= 0x3E )
    v7 = 0;
  else
    v7 = a2[62];
  if ( a3 <= 0x3F )
    v8 = 0;
  else
    v8 = a2[63] << 8;
  v117 = v6 | ((v8 | v7) << 16);
  if ( a3 <= 0x40 )
    v9 = 0;
  else
    v9 = a2[64];
  if ( a3 <= 0x41 )
    v10 = 0;
  else
    v10 = a2[65] << 8;
  *(_WORD *)(a1 + 50) = v9 | v10;
  if ( a3 <= 0x42 )
    v11 = 0;
  else
    v11 = a2[66];
  if ( a3 <= 0x43 )
    v12 = 0;
  else
    v12 = a2[67] << 8;
  *(_WORD *)(a1 + 52) = v11 | v12;
  if ( a3 <= 0x44 )
    v13 = 0;
  else
    v13 = a2[68];
  if ( a3 <= 0x45 )
    v14 = 0;
  else
    v14 = a2[69] << 8;
  *(_WORD *)(a1 + 54) = v13 | v14;
  if ( a3 <= 0x46 )
    v15 = 0;
  else
    v15 = a2[70];
  if ( a3 <= 0x47 )
    v16 = 0;
  else
    v16 = a2[71] << 8;
  *(_WORD *)(a1 + 56) = v15 | v16;
  if ( a3 <= 0x48 )
    v17 = 0;
  else
    v17 = a2[72];
  if ( a3 <= 0x49 )
    v18 = 0;
  else
    v18 = a2[73] << 8;
  *(_WORD *)(a1 + 58) = v17 | v18;
  *(_QWORD *)(a1 + 320) = a4;
  v105 = 16LL * *(unsigned __int16 *)(a1 + 56) + a4;
  *(_QWORD *)(a1 + 328) = v105;
  v106 = 272LL * *(unsigned __int16 *)(a1 + 58) + v105;
  if ( a3 <= 0x4A )
    v19 = 0;
  else
    v19 = a2[74];
  *(_DWORD *)(a1 + 60) = (v19 & 1) == 0;
  if ( a3 <= 0x4C )
    v20 = 0;
  else
    v20 = a2[76];
  if ( a3 <= 0x4D )
    v21 = 0;
  else
    v21 = a2[77] << 8;
  *(_WORD *)(a1 + 340) = v20 | v21;
  if ( a3 <= 0x4E )
    v22 = 0;
  else
    v22 = a2[78];
  if ( a3 <= 0x4F )
    v23 = 0;
  else
    v23 = a2[79] << 8;
  *(_WORD *)(a1 + 342) = v22 | v23;
  sub_5588FFED9B70(a1 + 64, 256LL, a2, a3, 80LL);
  v131 = v117 + 60LL;
  for ( i = 0; i < *(_WORD *)(a1 + 56); ++i )
  {
    if ( v131 + 7 >= a3 )
      v24 = 0;
    else
      v24 = a2[v131 + 7];
    if ( v131 + 8 >= a3 )
      v25 = 0;
    else
      v25 = a2[v131 + 8] << 8;
    v112 = v24 | v25;
    v111 = (unsigned __int16 *)(16LL * i + *(_QWORD *)(a1 + 320));
    if ( v131 + 5 >= a3 )
      v26 = 0;
    else
      v26 = a2[v131 + 5];
    if ( v131 + 6 >= a3 )
      v27 = 0;
    else
      v27 = a2[v131 + 6] << 8;
    *v111 = v26 | v27;
    *((_QWORD *)v111 + 1) = v106;
    v106 += 5LL * *(unsigned __int16 *)(a1 + 54) * *v111;
    if ( v131 >= a3 )
      v28 = 0;
    else
      v28 = a2[v131];
    if ( v131 + 1 >= a3 )
      v29 = 0;
    else
      v29 = a2[v131 + 1] << 8;
    v30 = v29 | v28;
    if ( v131 + 2 >= a3 )
      v31 = 0;
    else
      v31 = a2[v131 + 2];
    if ( v131 + 3 >= a3 )
      v32 = 0;
    else
      v32 = a2[v131 + 3] << 8;
    v132 = (v30 | ((v32 | v31) << 16)) + v131;
    if ( v112 )
    {
      v129 = 0;
      v128 = 0;
      while ( v129 < v112 )
      {
        if ( v129 + v132 >= a3 )
          v33 = 0;
        else
          v33 = a2[v132 + v129];
        v110 = v33;
        v109 = (_BYTE *)(*((_QWORD *)v111 + 1) + 5LL * v128);
        if ( v33 >= 0 )
        {
          *v109 = v33;
          if ( v129 + v132 + 1 >= a3 )
            v39 = 0;
          else
            v39 = a2[v129 + 1 + v132];
          v109[1] = v39;
          if ( v129 + v132 + 2 >= a3 )
            v40 = 0;
          else
            v40 = a2[v129 + 2 + v132];
          v109[2] = v40;
          if ( v129 + v132 + 3 >= a3 )
            v41 = 0;
          else
            v41 = a2[v129 + 3 + v132];
          v109[3] = v41;
          if ( v129 + v132 + 4 >= a3 )
            v42 = 0;
          else
            v42 = a2[v129 + 4 + v132];
          v109[4] = v42;
          v129 += 5;
        }
        else
        {
          ++v129;
          if ( (v33 & 1) != 0 )
          {
            if ( v129 + v132 >= a3 )
              v34 = 0;
            else
              v34 = a2[v132 + v129];
            *v109 = v34;
            ++v129;
          }
          else
          {
            *v109 = 0;
          }
          if ( (v110 & 2) != 0 )
          {
            if ( v129 + v132 >= a3 )
              v35 = 0;
            else
              v35 = a2[v132 + v129];
            v109[1] = v35;
            ++v129;
          }
          else
          {
            v109[1] = 0;
          }
          if ( (v110 & 4) != 0 )
          {
            if ( v129 + v132 >= a3 )
              v36 = 0;
            else
              v36 = a2[v132 + v129];
            v109[2] = v36;
            ++v129;
          }
          else
          {
            v109[2] = 0;
          }
          if ( (v110 & 8) != 0 )
          {
            if ( v129 + v132 >= a3 )
              v37 = 0;
            else
              v37 = a2[v132 + v129];
            v109[3] = v37;
            ++v129;
          }
          else
          {
            v109[3] = 0;
          }
          if ( (v110 & 0x10) != 0 )
          {
            if ( v129 + v132 >= a3 )
              v38 = 0;
            else
              v38 = a2[v132 + v129];
            v109[4] = v38;
            ++v129;
          }
          else
          {
            v109[4] = 0;
          }
        }
        ++v128;
      }
    }
    else
    {
      memset(*((void **)v111 + 1), 0, 5 * *(unsigned __int16 *)(a1 + 54) * (unsigned __int64)*v111);
    }
    v131 = v112 + v132;
  }
  for ( j = 0; j < *(_WORD *)(a1 + 58); ++j )
  {
    v126 = 0;
    v116 = *(_QWORD *)(a1 + 328) + 272LL * j;
    sub_5588FFED9B70(v116, 22LL, a2, a3, v131 + 4);
    if ( v131 + 27 >= a3 )
      v43 = 0;
    else
      v43 = a2[v131 + 27];
    if ( v131 + 28 >= a3 )
      v44 = 0;
    else
      v44 = a2[v131 + 28] << 8;
    *(_WORD *)(v116 + 24) = v43 | v44;
    if ( *(_WORD *)(v116 + 24) )
    {
      if ( v131 + 29 >= a3 )
        v45 = 0;
      else
        v45 = a2[v131 + 29];
      if ( v131 + 30 >= a3 )
        v46 = 0;
      else
        v46 = a2[v131 + 30] << 8;
      v47 = v46 | v45;
      if ( v131 + 31 >= a3 )
        v48 = 0;
      else
        v48 = a2[v131 + 31];
      if ( v131 + 32 >= a3 )
        v49 = 0;
      else
        v49 = a2[v131 + 32] << 8;
      v126 = v47 | ((v49 | v48) << 16);
      sub_5588FFED9B70(v116 + 26, 96LL, a2, a3, v131 + 33);
      if ( v131 + 225 >= a3 )
        v50 = 0;
      else
        v50 = a2[v131 + 225];
      *(_BYTE *)(v116 + 170) = v50;
      if ( v131 + 226 >= a3 )
        v51 = 0;
      else
        v51 = a2[v131 + 226];
      *(_BYTE *)(v116 + 226) = v51;
      for ( k = 0; k < *(_BYTE *)(v116 + 170); ++k )
      {
        if ( 4 * k + v131 + 129 >= a3 )
          v52 = 0;
        else
          v52 = a2[4 * k + 129 + v131];
        if ( 4 * k + v131 + 130 >= a3 )
          v53 = 0;
        else
          v53 = a2[4 * k + 130 + v131] << 8;
        *(_WORD *)(v116 + 4 * (k + 28LL) + 10) = v52 | v53;
        if ( 4 * k + v131 + 131 >= a3 )
          v54 = 0;
        else
          v54 = a2[4 * k + 131 + v131];
        if ( 4 * k + v131 + 132 >= a3 )
          v55 = 0;
        else
          v55 = a2[4 * k + 132 + v131] << 8;
        *(_WORD *)(v116 + 4 * (k + 28LL) + 12) = v54 | v55;
      }
      for ( m = 0; m < *(_BYTE *)(v116 + 226); ++m )
      {
        if ( 4 * m + v131 + 177 >= a3 )
          v56 = 0;
        else
          v56 = a2[4 * m + 177 + v131];
        if ( 4 * m + v131 + 178 >= a3 )
          v57 = 0;
        else
          v57 = a2[4 * m + 178 + v131] << 8;
        *(_WORD *)(v116 + 4 * (m + 44LL) + 2) = v56 | v57;
        if ( 4 * m + v131 + 179 >= a3 )
          v58 = 0;
        else
          v58 = a2[4 * m + 179 + v131];
        if ( 4 * m + v131 + 180 >= a3 )
          v59 = 0;
        else
          v59 = a2[4 * m + 180 + v131] << 8;
        *(_WORD *)(v116 + 4 * (m + 44LL) + 4) = v58 | v59;
      }
      if ( v131 + 227 >= a3 )
        v60 = 0;
      else
        v60 = a2[v131 + 227];
      *(_BYTE *)(v116 + 171) = v60;
      if ( v131 + 228 >= a3 )
        v61 = 0;
      else
        v61 = a2[v131 + 228];
      *(_BYTE *)(v116 + 172) = v61;
      if ( v131 + 229 >= a3 )
        v62 = 0;
      else
        v62 = a2[v131 + 229];
      *(_BYTE *)(v116 + 173) = v62;
      if ( v131 + 230 >= a3 )
        v63 = 0;
      else
        v63 = a2[v131 + 230];
      *(_BYTE *)(v116 + 227) = v63;
      if ( v131 + 231 >= a3 )
        v64 = 0;
      else
        v64 = a2[v131 + 231];
      *(_BYTE *)(v116 + 228) = v64;
      if ( v131 + 232 >= a3 )
        v65 = 0;
      else
        v65 = a2[v131 + 232];
      *(_BYTE *)(v116 + 229) = v65;
      if ( v131 + 233 >= a3 )
        v66 = 0;
      else
        v66 = a2[v131 + 233];
      *(_BYTE *)(v116 + 174) = v66 & 1;
      *(_BYTE *)(v116 + 175) = (v66 & 2) != 0;
      *(_BYTE *)(v116 + 176) = (v66 & 4) != 0;
      if ( v131 + 234 >= a3 )
        v67 = 0;
      else
        v67 = a2[v131 + 234];
      *(_BYTE *)(v116 + 230) = v67 & 1;
      *(_BYTE *)(v116 + 231) = (v67 & 2) != 0;
      *(_BYTE *)(v116 + 232) = (v67 & 4) != 0;
      if ( v131 + 235 >= a3 )
        v68 = 0;
      else
        v68 = a2[v131 + 235];
      *(_DWORD *)(v116 + 236) = v68;
      if ( *(_DWORD *)(v116 + 236) == 2 )
      {
        *(_DWORD *)(v116 + 236) = 1;
      }
      else if ( *(_DWORD *)(v116 + 236) == 1 )
      {
        *(_DWORD *)(v116 + 236) = 2;
      }
      if ( v131 + 236 >= a3 )
        v69 = 0;
      else
        v69 = a2[v131 + 236];
      *(_BYTE *)(v116 + 240) = v69;
      if ( v131 + 237 >= a3 )
        v70 = 0;
      else
        v70 = a2[v131 + 237];
      *(_BYTE *)(v116 + 241) = v70;
      if ( v131 + 238 >= a3 )
        v71 = 0;
      else
        v71 = a2[v131 + 238];
      *(_BYTE *)(v116 + 242) = v71;
      if ( v131 + 239 >= a3 )
        v72 = 0;
      else
        v72 = a2[v131 + 239];
      if ( v131 + 240 >= a3 )
        v73 = 0;
      else
        v73 = a2[v131 + 240] << 8;
      *(_WORD *)(v116 + 244) = v72 | v73;
      *(_QWORD *)(v116 + 264) = v106;
      v106 += 80LL * *(unsigned __int16 *)(v116 + 24);
    }
    else
    {
      *(_QWORD *)(v116 + 264) = 0LL;
    }
    if ( v131 >= a3 )
      v74 = 0;
    else
      v74 = a2[v131];
    if ( v131 + 1 >= a3 )
      v75 = 0;
    else
      v75 = a2[v131 + 1] << 8;
    v76 = v75 | v74;
    if ( v131 + 2 >= a3 )
      v77 = 0;
    else
      v77 = a2[v131 + 2];
    if ( v131 + 3 >= a3 )
      v78 = 0;
    else
      v78 = a2[v131 + 3] << 8;
    v131 += v76 | ((v78 | v77) << 16);
    for ( n = 0; n < *(_WORD *)(v116 + 24); ++n )
    {
      v113 = *(_QWORD *)(v116 + 264) + 80LL * n;
      if ( v131 >= a3 )
        v79 = 0;
      else
        v79 = a2[v131];
      if ( v131 + 1 >= a3 )
        v80 = 0;
      else
        v80 = a2[v131 + 1] << 8;
      v81 = v80 | v79;
      if ( v131 + 2 >= a3 )
        v82 = 0;
      else
        v82 = a2[v131 + 2];
      if ( v131 + 3 >= a3 )
        v83 = 0;
      else
        v83 = a2[v131 + 3] << 8;
      *(_DWORD *)(v113 + 24) = ((v83 | v82) << 16) | v81;
      if ( v131 + 4 >= a3 )
        v84 = 0;
      else
        v84 = a2[v131 + 4];
      if ( v131 + 5 >= a3 )
        v85 = 0;
      else
        v85 = a2[v131 + 5] << 8;
      v86 = v85 | v84;
      if ( v131 + 6 >= a3 )
        v87 = 0;
      else
        v87 = a2[v131 + 6];
      if ( v131 + 7 >= a3 )
        v88 = 0;
      else
        v88 = a2[v131 + 7] << 8;
      *(_DWORD *)(v113 + 28) = ((v88 | v87) << 16) | v86;
      if ( v131 + 8 >= a3 )
        v89 = 0;
      else
        v89 = a2[v131 + 8];
      if ( v131 + 9 >= a3 )
        v90 = 0;
      else
        v90 = a2[v131 + 9] << 8;
      v91 = v90 | v89;
      if ( v131 + 10 >= a3 )
        v92 = 0;
      else
        v92 = a2[v131 + 10];
      if ( v131 + 11 >= a3 )
        v93 = 0;
      else
        v93 = a2[v131 + 11] << 8;
      *(_DWORD *)(v113 + 32) = ((v93 | v92) << 16) | v91;
      *(_DWORD *)(v113 + 36) = *(_DWORD *)(v113 + 32) + *(_DWORD *)(v113 + 28);
      if ( v131 + 12 >= a3 )
        v94 = 0.0;
      else
        v94 = (float)a2[v131 + 12];
      *(float *)(v113 + 40) = v94 / 64.0;
      if ( v131 + 13 >= a3 )
        v95 = 0;
      else
        v95 = a2[v131 + 13];
      *(_BYTE *)(v113 + 44) = v95;
      if ( v131 + 14 >= a3 )
        v96 = 0;
      else
        v96 = a2[v131 + 14];
      if ( (v96 & 3) != 0 )
      {
        if ( (v96 & 3) == 1 )
          *(_DWORD *)(v113 + 48) = 1;
        else
          *(_DWORD *)(v113 + 48) = 2;
      }
      else
      {
        *(_DWORD *)(v113 + 48) = 0;
      }
      if ( (v96 & 0x10) != 0 )
        v97 = 16;
      else
        v97 = 8;
      *(_BYTE *)(v113 + 23) = v97;
      v98 = 0.0;
      if ( v131 + 15 < a3 )
        v98 = (float)a2[v131 + 15];
      *(float *)(v113 + 52) = v98 / 255.0;
      if ( v131 + 16 >= a3 )
        v99 = 0;
      else
        v99 = a2[v131 + 16];
      *(_BYTE *)(v113 + 56) = v99;
      sub_5588FFED9B70(v113, 22LL, a2, a3, 18LL);
      *(_QWORD *)(v113 + 72) = v106;
      if ( *(_BYTE *)(v113 + 23) == 16 )
      {
        v106 += 2LL * *(unsigned int *)(v113 + 24);
        *(_DWORD *)(v113 + 28) >>= 1;
        *(_DWORD *)(v113 + 32) >>= 1;
        *(_DWORD *)(v113 + 36) >>= 1;
        *(_DWORD *)(v113 + 24) >>= 1;
      }
      else
      {
        v106 += 4LL * *(unsigned int *)(v113 + 24);
      }
      v131 += v126;
    }
    for ( ii = 0; ii < *(_WORD *)(v116 + 24); ++ii )
    {
      v115 = *(_QWORD *)(v116 + 264) + 80LL * ii;
      v114 = *(_DWORD *)(v115 + 24);
      if ( *(_BYTE *)(v115 + 23) == 16 )
      {
        v121 = 0;
        for ( jj = 0; jj < v114; ++jj )
        {
          if ( 2 * jj + v131 >= a3 )
            v100 = 0;
          else
            v100 = a2[2 * jj + v131];
          if ( 2 * jj + v131 + 1 >= a3 )
            v101 = 0;
          else
            v101 = a2[2 * jj + 1 + v131] << 8;
          v121 += v100 | v101;
          *(float *)(4LL * jj + *(_QWORD *)(v115 + 72)) = (float)v121 / 32768.0;
        }
        v131 += (unsigned int)(2 * *(_DWORD *)(v115 + 24));
      }
      else
      {
        v119 = 0;
        for ( kk = 0; kk < v114; ++kk )
        {
          if ( kk + v131 >= a3 )
            v102 = 0;
          else
            v102 = a2[v131 + kk];
          v119 += v102;
          *(float *)(4LL * kk + *(_QWORD *)(v115 + 72)) = (float)v119 / 128.0;
        }
        v131 += *(unsigned int *)(v115 + 24);
      }
    }
  }
  return v106;
}
// 5588FFED9B70: using guessed type __int64 __fastcall sub_5588FFED9B70(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00005588FFEDC203) ----------------------------------------------------
__m64 __fastcall sub_5588FFEDC203(int a1, char a2)
{
  __m128i v2; // xmm0
  __m128i v3; // xmm0
  __m64 result; // xmm0_8
  unsigned __int8 v5; // [rsp+8h] [rbp-8h]

  v5 = a2 & 0x3F;
  switch ( a1 )
  {
    case 0:
      v2 = (__m128i)0x40C90FD8u;
      *(float *)v2.m128i_i32 = (float)(6.2831841 * (float)v5) / 64.0;
      v3 = _mm_cvtsi32_si128(_mm_cvtsi128_si32(v2));
      *(float *)v3.m128i_i32 = sinf(*(float *)v3.m128i_i32);
      result = (__m64)(_mm_cvtsi32_si128(_mm_cvtsi128_si32(v3)).m128i_u64[0] ^ 0x80000000);
      break;
    case 1:
      *((_DWORD *)&result + 1) = 0;
      *(float *)&result.m64_u64 = (float)(32 - v5) / 32.0;
      break;
    case 2:
      if ( v5 <= 0x1Fu )
        result = (__m64)3212836864LL;
      else
        result = (__m64)1065353216LL;
      break;
    case 3:
      dword_5589001421A4 = 1103515245 * dword_5589001421A4 + 12345;
      *((_DWORD *)&result + 1) = 0;
      *(float *)&result.m64_u64 = (float)((float)(HIWORD(dword_5589001421A4) & 0x7FFF) / 16384.0) - 1.0;
      break;
    case 4:
      *((_DWORD *)&result + 1) = 0;
      *(float *)&result.m64_u64 = (float)(v5 - 32) / 32.0;
      break;
    default:
      result = 0LL;
      break;
  }
  return result;
}
// 5589001421A4: using guessed type int dword_5589001421A4;

//----- (00005588FFEDC362) ----------------------------------------------------
__int64 __fastcall sub_564317C0C362(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  unsigned __int16 v3; // ax
  double v4; // xmm0_8
  __int64 v5; // [rsp+20h] [rbp-10h]
  float v6; // [rsp+2Ch] [rbp-4h]

  result = *(_QWORD *)(a2 + 8);
  if ( result )
  {
    result = *(unsigned __int8 *)(*(_QWORD *)(a2 + 8) + 241LL);
    if ( (_BYTE)result )
    {
      v5 = *(_QWORD *)(a2 + 8);
      v6 = 1.0;
      if ( (unsigned int)*(_WORD *)(a2 + 60) < *(unsigned __int8 *)(v5 + 240) )
        v6 = (float)((float)*(unsigned __int16 *)(a2 + 60) / (float)*(unsigned __int8 *)(v5 + 240)) + 0.0;
      v3 = *(_WORD *)(a2 + 60);
      *(_WORD *)(a2 + 60) = v3 + 1;
      v4 = sub_5588FFEDC203(*(unsigned int *)(v5 + 236), (unsigned __int8)((v3 * *(unsigned __int8 *)(v5 + 242)) >> 2));
      *(float *)(a2 + 80) = (float)((float)((float)*(unsigned __int8 *)(v5 + 241) * (float)(0.25 * *(float *)&v4)) / 15.0)
                          * v6;
      return sub_5588FFEDD04C(a1, a2);
    }
  }
  return result;
}
// 5588FFEDC203: using guessed type double __fastcall sub_564317C0C203(_QWORD, _QWORD);

//----- (00005588FFEDC4A9) ----------------------------------------------------
__int64 __fastcall sub_564317C0C4A9(__int64 a1, __int64 a2, unsigned __int8 a3, char a4)
{
  double v4; // xmm0_8

  v4 = sub_5588FFEDC203(*(unsigned int *)(a2 + 112), (unsigned __int8)(a4 * (a3 >> 4)));
  *(float *)(a2 + 120) = (float)((float)(a3 & 0xF) * (float)(*(float *)&v4 + *(float *)&v4)) / 15.0;
  return sub_5588FFEDD04C(a1, a2);
}
// 5588FFEDC203: using guessed type double __fastcall sub_564317C0C203(_QWORD, _QWORD);

//----- (00005588FFEDC531) ----------------------------------------------------
__int64 __fastcall sub_5588FFEDC531(__m128i a1, __int64 a2, __int64 a3, unsigned __int8 a4, char a5)
{
  __int64 result; // rax

  a1.m128i_u64[0] = (unsigned __int64)sub_5588FFEDC203(*(_DWORD *)(a3 + 124), a5 * (a4 >> 4));
  result = a3;
  *(float *)(a3 + 132) = (float)((float)(a4 & 0xF) * COERCE_FLOAT(_mm_cvtsi128_si32(a1) ^ 0x80000000)) / 15.0;
  return result;
}

//----- (00005588FFEDC5B5) ----------------------------------------------------
__int64 __fastcall sub_564317C0C5B5(__int64 a1, __int64 a2, unsigned __int8 a3, unsigned __int16 a4)
{
  if ( a4 % 3u == 2 )
  {
    *(_BYTE *)(a2 + 84) = 1;
    *(_BYTE *)(a2 + 85) = a3 >> 4;
  }
  else if ( a4 % 3u <= 2 )
  {
    if ( a4 % 3u )
    {
      *(_BYTE *)(a2 + 84) = 1;
      *(_BYTE *)(a2 + 85) = a3 & 0xF;
    }
    else
    {
      *(_BYTE *)(a2 + 84) = 0;
      *(_BYTE *)(a2 + 85) = 0;
    }
  }
  return sub_5588FFEDD04C(a1, a2);
}
// 5588FFEDC601: conditional instruction was optimized away because eax.4==1

//----- (00005588FFEDC660) ----------------------------------------------------
__int64 __fastcall sub_564317C0C660(__int64 a1, __int64 a2)
{
  __int64 result; // rax
  float v3; // xmm0_4
  float v4; // xmm0_4

  result = a2;
  if ( *(float *)(a2 + 100) != 0.0 )
  {
    result = a2;
    if ( *(float *)(a2 + 36) != *(float *)(a2 + 100) )
    {
      if ( *(float *)(a2 + 36) <= *(float *)(a2 + 100) )
      {
        if ( *(float *)(a2 + 100) > *(float *)(a2 + 36) )
        {
          v4 = *(_DWORD *)(a1 + 60) ? 1.0 : 4.0;
          *(float *)(a2 + 36) = (float)(v4 * (float)*(unsigned __int8 *)(a2 + 96)) + *(float *)(a2 + 36);
          if ( *(float *)(a2 + 36) > *(float *)(a2 + 100) )
            *(_DWORD *)(a2 + 36) = *(_DWORD *)(a2 + 100);
        }
      }
      else
      {
        if ( *(_DWORD *)(a1 + 60) )
          v3 = 1.0;
        else
          v3 = 4.0;
        *(float *)(a2 + 36) = *(float *)(a2 + 36) - (float)((float)*(unsigned __int8 *)(a2 + 96) * v3);
        if ( *(float *)(a2 + 100) > *(float *)(a2 + 36) )
          *(_DWORD *)(a2 + 36) = *(_DWORD *)(a2 + 100);
      }
      return sub_5588FFEDD04C(a1, a2);
    }
  }
  return result;
}

//----- (00005588FFEDC7E7) ----------------------------------------------------
__int64 __fastcall sub_564317C0C7E7(__int64 a1, __int64 a2, float a3)
{
  float v4; // [rsp+Ch] [rbp-14h]

  v4 = a3;
  if ( !*(_DWORD *)(a1 + 60) )
    v4 = 4.0 * a3;
  *(float *)(a2 + 36) = *(float *)(a2 + 36) + v4;
  if ( *(float *)(a2 + 36) < 0.0 )
    *(_DWORD *)(a2 + 36) = 0;
  return sub_5588FFEDD04C(a1, a2);
}

//----- (00005588FFEDC869) ----------------------------------------------------
__int64 __fastcall sub_564317C0C869(__int64 a1, unsigned __int8 a2)
{
  __int64 result; // rax

  if ( (a2 & 0xF0) == 0 || (result = a2 & 0xF, (a2 & 0xF) == 0) )
  {
    if ( (a2 & 0xF0) != 0 )
    {
      *(float *)(a1 + 56) = *(float *)(a1 + 56) + (float)((float)(a2 >> 4) / 255.0);
      result = a1;
      if ( *(float *)(a1 + 56) > 1.0 )
      {
        result = a1;
        *(_DWORD *)(a1 + 56) = 1065353216;
      }
    }
    else
    {
      *(float *)(a1 + 56) = *(float *)(a1 + 56) - (float)((float)(a2 & 0xF) / 255.0);
      result = a1;
      if ( *(float *)(a1 + 56) < 0.0 )
      {
        result = a1;
        *(_DWORD *)(a1 + 56) = 0;
      }
    }
  }
  return result;
}

//----- (00005588FFEDC95D) ----------------------------------------------------
__int64 __fastcall sub_564317C0C95D(__int64 a1, unsigned __int8 a2)
{
  __int64 result; // rax

  if ( (a2 & 0xF0) == 0 || (result = a2 & 0xF, (a2 & 0xF) == 0) )
  {
    if ( (a2 & 0xF0) != 0 )
    {
      *(float *)(a1 + 52) = *(float *)(a1 + 52) + (float)((float)(a2 >> 4) / 64.0);
      result = a1;
      if ( *(float *)(a1 + 52) > 1.0 )
      {
        result = a1;
        *(_DWORD *)(a1 + 52) = 1065353216;
      }
    }
    else
    {
      *(float *)(a1 + 52) = *(float *)(a1 + 52) - (float)((float)(a2 & 0xF) / 64.0);
      result = a1;
      if ( *(float *)(a1 + 52) < 0.0 )
      {
        result = a1;
        *(_DWORD *)(a1 + 52) = 0;
      }
    }
  }
  return result;
}

//----- (00005588FFEDCA51) ----------------------------------------------------
float __fastcall sub_564317C0CA51(unsigned __int16 *a1, unsigned __int16 *a2, unsigned __int16 a3)
{
  float v4; // [rsp+20h] [rbp-4h]

  if ( *a1 >= a3 )
    return (float)a1[1];
  if ( a3 >= *a2 )
    return (float)a2[1];
  v4 = (float)(a3 - *a1) / (float)(*a2 - *a1);
  return (float)((float)a2[1] * v4) + (float)((float)a1[1] * (float)(1.0 - v4));
}

//----- (00005588FFEDCB2B) ----------------------------------------------------
__int64 __fastcall sub_564317C0CB2B(__int64 a1)
{
  __int64 result; // rax

  result = *(unsigned __int16 *)(a1 + 50);
  if ( *(unsigned __int8 *)(a1 + 360) >= (unsigned __int16)result )
  {
    result = a1;
    *(_BYTE *)(a1 + 360) = *(_WORD *)(a1 + 52);
  }
  return result;
}

//----- (00005588FFEDCB65) ----------------------------------------------------
float __fastcall sub_564317C0CB65(float a1)
{
  return 7680.0 - (float)(a1 * 64.0);
}

//----- (00005588FFEDCB8D) ----------------------------------------------------
float __fastcall sub_564317C0CB8D(float a1)
{
  return powf(2.0, (float)(4608.0 - a1) / 768.0) * 8363.0;
}

//----- (00005588FFEDCBD3) ----------------------------------------------------
float __fastcall sub_564317C0CBD3(float a1)
{
  char v2; // [rsp+Ah] [rbp-Ah]
  unsigned __int8 v3; // [rsp+Bh] [rbp-9h]
  unsigned __int16 v4; // [rsp+10h] [rbp-4h]
  unsigned __int16 v5; // [rsp+12h] [rbp-2h]

  v3 = (int)a1 % 0xCu;
  v2 = (int)(float)((float)(a1 / 12.0) - 2.0);
  v5 = word_5588FFEE2040[v3];
  v4 = word_5588FFEE2040[v3 + 1];
  if ( v2 <= 0 )
  {
    if ( v2 < 0 )
    {
      v5 <<= -v2;
      v4 <<= -v2;
    }
  }
  else
  {
    v5 = (int)v5 >> v2;
    v4 = (int)v4 >> v2;
  }
  return (float)((float)(v4 - v5) * (float)(a1 - (float)(int)a1)) + (float)v5;
}
// 5588FFEE2040: using guessed type _WORD word_564317C12040[16];

//----- (00005588FFEDCD20) ----------------------------------------------------
float __fastcall sub_564317C0CD20(float a1)
{
  if ( a1 == 0.0 )
    return 0.0;
  else
    return 7093789.0 / (float)(a1 + a1);
}

//----- (00005588FFEDCD5D) ----------------------------------------------------
__m128i __fastcall sub_5588FFEDCD5D(__int64 a1, float a2)
{
  int v2; // eax
  __m128i v3; // xmm0
  __m128i v4; // xmm0
  unsigned int v5; // eax

  v2 = *(_DWORD *)(a1 + 60);
  if ( v2 )
  {
    if ( v2 == 1 )
    {
      v4 = _mm_cvtsi32_si128(LODWORD(a2));
      *(double *)v4.m128i_i64 = sub_5588FFEDCBD3(*(double *)v4.m128i_i64);
      v5 = _mm_cvtsi128_si32(v4);
    }
    else
    {
      v5 = 0;
    }
  }
  else
  {
    v3 = _mm_cvtsi32_si128(LODWORD(a2));
    *(double *)v3.m128i_i64 = sub_5588FFEDCB65(*(double *)v3.m128i_i64);
    v5 = _mm_cvtsi128_si32(v3);
  }
  return _mm_cvtsi32_si128(v5);
}
// 5588FFEDCB65: using guessed type double __fastcall sub_5588FFEDCB65(double);
// 5588FFEDCBD3: using guessed type double __fastcall sub_5588FFEDCBD3(double);

//----- (00005588FFEDCDB0) ----------------------------------------------------
__m128i __fastcall sub_5588FFEDCDB0(__int64 a1, __m128i a2, float a3)
{
  int v3; // eax
  __m128i v4; // xmm0
  __m128i v5; // xmm0
  __m128i v6; // xmm0
  __m128i v7; // xmm0
  __m128i v8; // xmm0
  unsigned int v9; // eax
  unsigned int v11; // [rsp+14h] [rbp-Ch]
  unsigned __int8 j; // [rsp+19h] [rbp-7h]
  unsigned __int16 v13; // [rsp+1Ah] [rbp-6h]
  unsigned __int16 v14; // [rsp+1Ch] [rbp-4h]
  char i; // [rsp+1Eh] [rbp-2h]
  unsigned __int8 v16; // [rsp+1Fh] [rbp-1h]

  v3 = *(_DWORD *)(a1 + 60);
  if ( v3 )
  {
    if ( v3 == 1 )
    {
      if ( a3 == 0.0 )
      {
        v5 = _mm_cvtsi32_si128(a2.m128i_u32[0]);
        *(double *)v5.m128i_i64 = sub_5588FFEDCD20(*(double *)v5.m128i_i64);
        v9 = _mm_cvtsi128_si32(v5);
      }
      else
      {
        i = 0;
        v16 = 0;
        if ( *(float *)a2.m128i_i32 <= (float)1712 )
        {
          if ( (float)856 > *(float *)a2.m128i_i32 )
          {
            for ( i = 1; (float)(856 >> i) > *(float *)a2.m128i_i32; ++i )
              ;
          }
        }
        else
        {
          for ( i = -1; *(float *)a2.m128i_i32 > (float)(1712 << -i); --i )
            ;
        }
        for ( j = 0; j <= 0xBu; ++j )
        {
          v14 = word_5588FFEE2040[j];
          v13 = word_5588FFEE2040[j + 1];
          if ( i <= 0 )
          {
            if ( i < 0 )
            {
              v14 <<= -i;
              v13 <<= -i;
            }
          }
          else
          {
            v14 = (int)v14 >> i;
            v13 = (int)v13 >> i;
          }
          if ( *(float *)a2.m128i_i32 >= (float)v13 && (float)v14 >= *(float *)a2.m128i_i32 )
          {
            v16 = j;
            break;
          }
        }
        *(float *)&v11 = (float)((float)(*(float *)a2.m128i_i32 - (float)v14) / (float)(v13 - v14))
                       + (float)((float)((float)(i + 2) * 12.0) + (float)v16);
        v6 = (__m128i)v11;
        *(float *)v6.m128i_i32 = *(float *)&v11 + a3;
        v7 = _mm_cvtsi32_si128(_mm_cvtsi128_si32(v6));
        *(double *)v7.m128i_i64 = sub_5588FFEDCBD3(*(double *)v7.m128i_i64);
        v8 = _mm_cvtsi32_si128(_mm_cvtsi128_si32(v7));
        *(double *)v8.m128i_i64 = sub_5588FFEDCD20(*(double *)v8.m128i_i64);
        v9 = _mm_cvtsi128_si32(v8);
      }
    }
    else
    {
      v9 = 0;
    }
  }
  else
  {
    a2 = (__m128i)a2.m128i_u32[0];
    *(float *)a2.m128i_i32 = *(float *)a2.m128i_i32 - (float)(a3 * 64.0);
    v4 = _mm_cvtsi32_si128(_mm_cvtsi128_si32(a2));
    *(double *)v4.m128i_i64 = sub_5588FFEDCB8D(*(double *)v4.m128i_i64);
    v9 = _mm_cvtsi128_si32(v4);
  }
  return _mm_cvtsi32_si128(v9);
}
// 5588FFEDCFE2: variable 'v14' is possibly undefined
// 5588FFEDCFF7: variable 'v13' is possibly undefined
// 5588FFEDCB8D: using guessed type double __fastcall sub_5588FFEDCB8D(double);
// 5588FFEDCBD3: using guessed type double __fastcall sub_5588FFEDCBD3(double);
// 5588FFEDCD20: using guessed type double __fastcall sub_5588FFEDCD20(double);
// 5588FFEE2040: using guessed type _WORD word_5588FFEE2040[16];

//----- (00005588FFEDD04C) ----------------------------------------------------
__int64 __fastcall sub_5588FFEDD04C(__int64 a1, __int64 a2)
{
  float v2; // xmm0_4
  __int64 result; // rax

  if ( *(_BYTE *)(a2 + 85) )
    v2 = (float)*(unsigned __int8 *)(a2 + 85);
  else
    v2 = *(float *)(a2 + 80) + *(float *)(a2 + 120);
  *(_DWORD *)(a2 + 40) = _mm_cvtsi128_si32(sub_5588FFEDCDB0(a1, _mm_cvtsi32_si128(*(_DWORD *)(a2 + 36)), v2));
  result = a2;
  *(float *)(a2 + 44) = *(float *)(a2 + 40) / (float)*(int *)(a1 + 336);
  return result;
}

//----- (00005588FFEDD106) ----------------------------------------------------
char __fastcall sub_5588FFEDD106(__int64 a1, __int64 a2, unsigned __int8 *a3, __m128i a4)
{
  __int64 v4; // rax
  int v5; // edx
  char v6; // al
  float v7; // xmm0_4
  __m128i v8; // xmm3
  __m128i v9; // xmm4
  float v10; // xmm0_4
  __m128 v11; // xmm0
  __m128i v12; // xmm5
  int v15; // [rsp+28h] [rbp-18h]
  __int64 v16; // [rsp+30h] [rbp-10h]
  unsigned int i; // [rsp+3Ch] [rbp-4h]

  if ( a3[1] )
  {
    if ( (*(_BYTE *)(*(_QWORD *)(a2 + 24) + 3LL) == 3
       || *(_BYTE *)(*(_QWORD *)(a2 + 24) + 3LL) == 5
       || *(_BYTE *)(*(_QWORD *)(a2 + 24) + 2LL) >> 4 == 15)
      && *(_QWORD *)(a2 + 8)
      && *(_QWORD *)(a2 + 16) )
    {
      sub_5588FFEDE0B4(a1, a2, 6);
    }
    else if ( (unsigned int)*(_WORD *)(a1 + 58) >= a3[1] )
    {
      *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 328) + 272LL * a3[1] - 272;
      if ( !*a3 && *(_QWORD *)(a2 + 16) )
        sub_5588FFEDE0B4(a1, a2, 4);
    }
    else
    {
      sub_5588FFEDE283(a2);
      *(_QWORD *)(a2 + 8) = 0LL;
      *(_QWORD *)(a2 + 16) = 0LL;
    }
  }
  if ( *a3 && *a3 <= 0x60u )
  {
    v16 = *(_QWORD *)(a2 + 8);
    if ( (*(_BYTE *)(*(_QWORD *)(a2 + 24) + 3LL) == 3
       || *(_BYTE *)(*(_QWORD *)(a2 + 24) + 3LL) == 5
       || *(_BYTE *)(*(_QWORD *)(a2 + 24) + 2LL) >> 4 == 15)
      && v16
      && *(_QWORD *)(a2 + 16) )
    {
      *(float *)a2 = (float)((float)((float)*(char *)(*(_QWORD *)(a2 + 16) + 44LL) / 128.0)
                           + (float)(*a3 + *(char *)(*(_QWORD *)(a2 + 16) + 56LL)))
                   - 1.0;
      *(_DWORD *)(a2 + 100) = _mm_cvtsi128_si32(sub_5588FFEDCD5D(a1, *(float *)a2));
    }
    else if ( v16
           && *(_WORD *)(*(_QWORD *)(a2 + 8) + 24LL)
           && *(unsigned __int8 *)(v16 + *a3 - 1 + 26) < (unsigned int)*(_WORD *)(v16 + 24) )
    {
      for ( i = 0; i <= 0x1F; ++i )
      {
        *(float *)a4.m128i_i32 = sub_5588FFEDF5E3(a2);
        *(_DWORD *)(a2 + 4 * (i + 44LL)) = _mm_cvtsi128_si32(a4);
      }
      *(_QWORD *)(a2 + 168) = 0LL;
      *(_QWORD *)(a2 + 16) = *(_QWORD *)(v16 + 264) + 80LL * *(unsigned __int8 *)(v16 + *a3 - 1 + 26);
      *(float *)a2 = (float)((float)((float)*(char *)(*(_QWORD *)(a2 + 16) + 44LL) / 128.0)
                           + (float)(*a3 + *(char *)(*(_QWORD *)(a2 + 16) + 56LL)))
                   - 1.0;
      *(_DWORD *)(a2 + 4) = *(_DWORD *)a2;
      if ( a3[1] )
        sub_5588FFEDE0B4(a1, a2, 0);
      else
        sub_5588FFEDE0B4(a1, a2, 1);
    }
    else
    {
      sub_5588FFEDE283(a2);
    }
  }
  else if ( *a3 == 97 )
  {
    sub_5588FFEDE29B(a2);
  }
  switch ( a3[2] >> 4 )
  {
    case 1:
    case 2:
    case 3:
    case 4:
      goto LABEL_36;
    case 5:
      if ( a3[2] <= 0x50u )
LABEL_36:
        *(float *)(a2 + 52) = (float)(a3[2] - 16) / 64.0;
      break;
    case 8:
      sub_5588FFEDC95D(a2, a3[2] & 0xF);
      break;
    case 9:
      sub_5588FFEDC95D(a2, (unsigned __int8)(16 * a3[2]));
      break;
    case 10:
      *(_BYTE *)(a2 + 117) = *(_BYTE *)(a2 + 117) & 0xF | (16 * a3[2]);
      break;
    case 12:
      *(float *)(a2 + 56) = (float)((unsigned __int8)(16 * a3[2]) | a3[2] & 0xFu) / 255.0;
      break;
    case 15:
      if ( (a3[2] & 0xF) != 0 )
        *(_BYTE *)(a2 + 96) = (16 * a3[2]) | a3[2] & 0xF;
      break;
    default:
      break;
  }
  LOBYTE(v4) = a3[3];
  switch ( (char)v4 )
  {
    case 1:
      LOBYTE(v4) = a3[4];
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a2;
        *(_BYTE *)(a2 + 90) = a3[4];
      }
      break;
    case 2:
      LOBYTE(v4) = a3[4];
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a2;
        *(_BYTE *)(a2 + 91) = a3[4];
      }
      break;
    case 3:
      LOBYTE(v4) = a3[4];
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a2;
        *(_BYTE *)(a2 + 96) = a3[4];
      }
      break;
    case 4:
      if ( (a3[4] & 0xF) != 0 )
        *(_BYTE *)(a2 + 117) = *(_BYTE *)(a2 + 117) & 0xF0 | a3[4] & 0xF;
      LOBYTE(v4) = a3[4] >> 4;
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a2;
        *(_BYTE *)(a2 + 117) = a3[4] & 0xF0 | *(_BYTE *)(a2 + 117) & 0xF;
      }
      break;
    case 5:
      LOBYTE(v4) = a3[4];
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a2;
        *(_BYTE *)(a2 + 86) = a3[4];
      }
      break;
    case 6:
      LOBYTE(v4) = a3[4];
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a2;
        *(_BYTE *)(a2 + 86) = a3[4];
      }
      break;
    case 7:
      if ( (a3[4] & 0xF) != 0 )
        *(_BYTE *)(a2 + 129) = *(_BYTE *)(a2 + 129) & 0xF0 | a3[4] & 0xF;
      LOBYTE(v4) = a3[4] >> 4;
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a2;
        *(_BYTE *)(a2 + 129) = a3[4] & 0xF0 | *(_BYTE *)(a2 + 129) & 0xF;
      }
      break;
    case 8:
      LOBYTE(v4) = a2;
      *(float *)(a2 + 56) = (float)a3[4] / 255.0;
      break;
    case 9:
      v4 = *(_QWORD *)(a2 + 16);
      if ( v4 )
      {
        LOBYTE(v4) = *a3;
        if ( *a3 )
        {
          LOBYTE(v4) = *a3;
          if ( *a3 <= 0x60u )
          {
            v5 = a3[4];
            if ( *(_BYTE *)(*(_QWORD *)(a2 + 16) + 23LL) == 16 )
              v6 = 7;
            else
              v6 = 8;
            v15 = v5 << v6;
            if ( (unsigned int)(v5 << v6) < *(_DWORD *)(*(_QWORD *)(a2 + 16) + 24LL) )
            {
              LOBYTE(v4) = a2;
              *(float *)(a2 + 32) = (float)v15;
            }
            else
            {
              LOBYTE(v4) = a2;
              *(_DWORD *)(a2 + 32) = -1082130432;
            }
          }
        }
      }
      break;
    case 10:
      LOBYTE(v4) = a3[4];
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a2;
        *(_BYTE *)(a2 + 86) = a3[4];
      }
      break;
    case 11:
      LOWORD(v4) = *(_WORD *)(a1 + 50);
      if ( a3[4] < (unsigned __int16)v4 )
      {
        *(_BYTE *)(a1 + 376) = 1;
        LOBYTE(v4) = a1;
        *(_BYTE *)(a1 + 378) = a3[4];
      }
      break;
    case 12:
      if ( a3[4] > 0x40u )
        v7 = 64.0;
      else
        v7 = (float)a3[4];
      LOBYTE(v4) = a2;
      *(float *)(a2 + 52) = v7 / 64.0;
      break;
    case 13:
      *(_BYTE *)(a1 + 377) = 1;
      LOBYTE(v4) = a1;
      *(_BYTE *)(a1 + 379) = (a3[4] & 0xF) + 10 * (a3[4] >> 4);
      break;
    case 14:
      LOBYTE(v4) = a3[4] >> 4;
      switch ( (char)v4 )
      {
        case 1:
          if ( (a3[4] & 0xF) != 0 )
            *(_BYTE *)(a2 + 92) = a3[4] & 0xF;
          v8 = 0LL;
          *(float *)v8.m128i_i32 = (float)-*(unsigned __int8 *)(a2 + 92);
          LOBYTE(v4) = sub_5588FFEDC7E7(a1, a2, *(double *)_mm_cvtsi32_si128(_mm_cvtsi128_si32(v8)).m128i_i64);
          break;
        case 2:
          if ( (a3[4] & 0xF) != 0 )
            *(_BYTE *)(a2 + 93) = a3[4] & 0xF;
          v9 = 0LL;
          *(float *)v9.m128i_i32 = (float)*(unsigned __int8 *)(a2 + 93);
          LOBYTE(v4) = sub_5588FFEDC7E7(a1, a2, *(double *)_mm_cvtsi32_si128(_mm_cvtsi128_si32(v9)).m128i_i64);
          break;
        case 4:
          *(_DWORD *)(a2 + 112) = a3[4] & 3;
          LOBYTE(v4) = a2;
          *(_BYTE *)(a2 + 116) = (a3[4] & 4) == 0;
          break;
        case 5:
          LOBYTE(v4) = **(_BYTE **)(a2 + 24);
          if ( (_BYTE)v4 )
          {
            LOBYTE(v4) = **(_BYTE **)(a2 + 24);
            if ( (unsigned __int8)v4 <= 0x60u )
            {
              v4 = *(_QWORD *)(a2 + 16);
              if ( v4 )
              {
                *(float *)a2 = (float)((float)((float)(16 * ((a3[4] & 0xF) - 8)) / 128.0)
                                     + (float)(**(unsigned __int8 **)(a2 + 24) + *(char *)(*(_QWORD *)(a2 + 16) + 56LL)))
                             - 1.0;
                *(_DWORD *)(a2 + 36) = _mm_cvtsi128_si32(sub_5588FFEDCD5D(a1, *(float *)a2));
                LOBYTE(v4) = sub_5588FFEDD04C(a1, a2);
              }
            }
          }
          break;
        case 6:
          if ( (a3[4] & 0xF) != 0 )
          {
            if ( (a3[4] & 0xF) == *(_BYTE *)(a2 + 107) )
            {
              LOBYTE(v4) = a2;
              *(_BYTE *)(a2 + 107) = 0;
            }
            else
            {
              ++*(_BYTE *)(a2 + 107);
              *(_BYTE *)(a1 + 376) = 1;
              *(_BYTE *)(a1 + 379) = *(_BYTE *)(a2 + 106);
              LOBYTE(v4) = a1;
              *(_BYTE *)(a1 + 378) = *(_BYTE *)(a1 + 360);
            }
          }
          else
          {
            *(_BYTE *)(a2 + 106) = *(_BYTE *)(a1 + 361);
            LOBYTE(v4) = a1;
            *(_BYTE *)(a1 + 379) = *(_BYTE *)(a2 + 106);
          }
          break;
        case 7:
          *(_DWORD *)(a2 + 124) = a3[4] & 3;
          LOBYTE(v4) = a2;
          *(_BYTE *)(a2 + 128) = (a3[4] & 4) == 0;
          break;
        case 10:
          if ( (a3[4] & 0xF) != 0 )
            *(_BYTE *)(a2 + 87) = a3[4] & 0xF;
          LOBYTE(v4) = sub_5588FFEDC95D(a2, (unsigned __int8)(16 * *(_BYTE *)(a2 + 87)));
          break;
        case 11:
          if ( (a3[4] & 0xF) != 0 )
            *(_BYTE *)(a2 + 87) = a3[4] & 0xF;
          LOBYTE(v4) = sub_5588FFEDC95D(a2, *(unsigned __int8 *)(a2 + 87));
          break;
        case 13:
          LOBYTE(v4) = *a3;
          if ( !*a3 )
          {
            LOBYTE(v4) = a3[1];
            if ( !(_BYTE)v4 )
            {
              if ( (*(_BYTE *)(*(_QWORD *)(a2 + 24) + 4LL) & 0xF) != 0 )
              {
                *(_DWORD *)a2 = *(_DWORD *)(a2 + 4);
                LOBYTE(v4) = sub_5588FFEDE0B4(a1, a2, 1);
              }
              else
              {
                LOBYTE(v4) = sub_5588FFEDE0B4(a1, a2, 7);
              }
            }
          }
          break;
        case 14:
          LOBYTE(v4) = a1;
          *(_WORD *)(a1 + 380) = *(_WORD *)(a1 + 340) * (*(_BYTE *)(*(_QWORD *)(a2 + 24) + 4LL) & 0xF);
          break;
        default:
          return v4;
      }
      break;
    case 15:
      LOBYTE(v4) = a3[4];
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a1;
        if ( a3[4] > 0x1Fu )
          *(_WORD *)(a1 + 342) = a3[4];
        else
          *(_WORD *)(a1 + 340) = a3[4];
      }
      break;
    case 16:
      if ( a3[4] > 0x40u )
        v10 = 64.0;
      else
        v10 = (float)a3[4];
      LOBYTE(v4) = a1;
      *(float *)(a1 + 344) = v10 / 64.0;
      break;
    case 17:
      LOBYTE(v4) = a3[4];
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a2;
        *(_BYTE *)(a2 + 88) = a3[4];
      }
      break;
    case 21:
      *(_WORD *)(a2 + 76) = a3[4];
      LOBYTE(v4) = a2;
      *(_WORD *)(a2 + 78) = a3[4];
      break;
    case 25:
      LOBYTE(v4) = a3[4];
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a2;
        *(_BYTE *)(a2 + 89) = a3[4];
      }
      break;
    case 27:
      LOBYTE(v4) = a3[4];
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a2;
        if ( a3[4] >> 4 )
          *(_BYTE *)(a2 + 104) = a3[4];
        else
          *(_BYTE *)(a2 + 104) = *(_BYTE *)(a2 + 104) & 0xF0 | a3[4] & 0xF;
      }
      break;
    case 29:
      LOBYTE(v4) = a3[4];
      if ( (_BYTE)v4 )
      {
        LOBYTE(v4) = a2;
        *(_BYTE *)(a2 + 136) = a3[4];
      }
      break;
    case 33:
      LODWORD(v4) = a3[4] >> 4;
      if ( (_DWORD)v4 == 1 )
      {
        if ( (a3[4] & 0xF) != 0 )
          *(_BYTE *)(a2 + 94) = a3[4] & 0xF;
        v11 = 0LL;
        v11.m128_f32[0] = (float)*(unsigned __int8 *)(a2 + 94);
        LOBYTE(v4) = sub_5588FFEDC7E7(
                       a1,
                       a2,
                       *(double *)_mm_cvtsi32_si128(_mm_cvtsi128_si32((__m128i)_mm_xor_ps(v11, (__m128)0x80000000))).m128i_i64);
      }
      else if ( (_DWORD)v4 == 2 )
      {
        if ( (a3[4] & 0xF) != 0 )
          *(_BYTE *)(a2 + 95) = a3[4] & 0xF;
        v12 = 0LL;
        *(float *)v12.m128i_i32 = (float)*(unsigned __int8 *)(a2 + 95);
        LOBYTE(v4) = sub_5588FFEDC7E7(a1, a2, *(double *)_mm_cvtsi32_si128(_mm_cvtsi128_si32(v12)).m128i_i64);
      }
      break;
    default:
      return v4;
  }
  return v4;
}
// 5588FFEDC7E7: using guessed type __int64 __fastcall sub_5588FFEDC7E7(_QWORD, _QWORD, double);
// 5588FFEDC95D: using guessed type __int64 __fastcall sub_5588FFEDC95D(_QWORD, _QWORD);
// 5588FFEDE283: using guessed type __int64 __fastcall sub_5588FFEDE283(_QWORD);
// 5588FFEDE29B: using guessed type __int64 __fastcall sub_5588FFEDE29B(_QWORD);

//----- (00005588FFEDE0B4) ----------------------------------------------------
__int64 __fastcall sub_5588FFEDE0B4(__int64 a1, __int64 a2, char a3)
{
  __int64 result; // rax

  if ( (a3 & 4) == 0 )
  {
    *(_DWORD *)(a2 + 32) = 0;
    *(_BYTE *)(a2 + 48) = 1;
  }
  if ( *(_QWORD *)(a2 + 16) )
  {
    if ( (a3 & 1) == 0 )
      *(_DWORD *)(a2 + 52) = *(_DWORD *)(*(_QWORD *)(a2 + 16) + 40LL);
    *(_DWORD *)(a2 + 56) = *(_DWORD *)(*(_QWORD *)(a2 + 16) + 52LL);
  }
  *(_BYTE *)(a2 + 62) = 1;
  *(_DWORD *)(a2 + 68) = 1065353216;
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a2 + 68);
  *(_DWORD *)(a2 + 72) = 1056964608;
  *(_WORD *)(a2 + 78) = 0;
  *(_WORD *)(a2 + 76) = *(_WORD *)(a2 + 78);
  *(_DWORD *)(a2 + 120) = 0;
  *(_DWORD *)(a2 + 132) = 0;
  *(_BYTE *)(a2 + 137) = 0;
  *(_WORD *)(a2 + 60) = 0;
  if ( *(_BYTE *)(a2 + 116) )
    *(_WORD *)(a2 + 118) = 0;
  if ( *(_BYTE *)(a2 + 128) )
    *(_BYTE *)(a2 + 130) = 0;
  if ( (a3 & 2) == 0 )
  {
    *(_DWORD *)(a2 + 36) = _mm_cvtsi128_si32(sub_5588FFEDCD5D(a1, *(float *)a2));
    sub_5588FFEDD04C(a1, a2);
  }
  *(_QWORD *)(a2 + 144) = *(_QWORD *)(a1 + 368);
  if ( *(_QWORD *)(a2 + 8) )
    *(_QWORD *)(*(_QWORD *)(a2 + 8) + 248LL) = *(_QWORD *)(a1 + 368);
  result = *(_QWORD *)(a2 + 16);
  if ( result )
  {
    result = *(_QWORD *)(a2 + 16);
    *(_QWORD *)(result + 64) = *(_QWORD *)(a1 + 368);
  }
  return result;
}

//----- (00005588FFEDE283) ----------------------------------------------------
__int64 __fastcall sub_564317C0E283(__int64 a1)
{
  __int64 result; // rax

  result = a1;
  *(_DWORD *)(a1 + 52) = 0;
  return result;
}

//----- (00005588FFEDE29B) ----------------------------------------------------
__int64 __fastcall sub_564317C0E29B(__int64 a1)
{
  __int64 result; // rax

  *(_BYTE *)(a1 + 62) = 0;
  if ( !*(_QWORD *)(a1 + 8) )
    return sub_5588FFEDE283(a1);
  result = *(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + 174LL) ^ 1u;
  if ( *(_BYTE *)(*(_QWORD *)(a1 + 8) + 174LL) != 1 )
    return sub_5588FFEDE283(a1);
  return result;
}
// 5588FFEDE283: using guessed type __int64 __fastcall sub_564317C0E283(_QWORD);

//----- (00005588FFEDE2E1) ----------------------------------------------------
__int64 __fastcall sub_5588FFEDE2E1(__int64 a1, __m128i a2)
{
  _BYTE *v2; // rdx
  char v3; // al
  __int64 result; // rax
  __int64 v5; // [rsp+10h] [rbp-20h]
  unsigned __int8 *v6; // [rsp+18h] [rbp-18h]
  __int64 v7; // [rsp+20h] [rbp-10h]
  unsigned __int8 i; // [rsp+2Eh] [rbp-2h]
  char v9; // [rsp+2Fh] [rbp-1h]

  if ( *(_BYTE *)(a1 + 376) )
  {
    *(_BYTE *)(a1 + 360) = *(_BYTE *)(a1 + 378);
    *(_BYTE *)(a1 + 361) = *(_BYTE *)(a1 + 379);
    *(_BYTE *)(a1 + 376) = 0;
    *(_BYTE *)(a1 + 377) = 0;
    *(_BYTE *)(a1 + 379) = 0;
    sub_5588FFEDCB2B(a1);
  }
  else if ( *(_BYTE *)(a1 + 377) )
  {
    ++*(_BYTE *)(a1 + 360);
    *(_BYTE *)(a1 + 361) = *(_BYTE *)(a1 + 379);
    *(_BYTE *)(a1 + 377) = 0;
    *(_BYTE *)(a1 + 379) = 0;
    sub_5588FFEDCB2B(a1);
  }
  v7 = *(_QWORD *)(a1 + 320) + 16LL * *(unsigned __int8 *)(a1 + *(unsigned __int8 *)(a1 + 360) + 64);
  v9 = 0;
  for ( i = 0; i < (unsigned int)*(_WORD *)(a1 + 54); ++i )
  {
    v6 = (unsigned __int8 *)(*(_QWORD *)(v7 + 8)
                           + 5 * (i + (__int64)(*(unsigned __int8 *)(a1 + 361) * *(unsigned __int16 *)(a1 + 54))));
    v5 = *(_QWORD *)(a1 + 400) + 312LL * i;
    *(_QWORD *)(v5 + 24) = v6;
    if ( v6[3] == 14 && v6[4] >> 4 == 13 )
      *(_BYTE *)(v5 + 105) = v6[4] & 0xF;
    else
      sub_5588FFEDD106(a1, v5, v6, a2);
    if ( v9 != 1 && *(_BYTE *)(v5 + 107) )
      v9 = 1;
  }
  if ( v9 != 1 )
  {
    v2 = (_BYTE *)((*(unsigned __int8 *)(a1 + 360) << 8) + *(unsigned __int8 *)(a1 + 361) + *(_QWORD *)(a1 + 384));
    v3 = (*v2)++;
    *(_BYTE *)(a1 + 392) = v3;
  }
  ++*(_BYTE *)(a1 + 361);
  result = *(unsigned __int8 *)(a1 + 376) ^ 1u;
  if ( *(_BYTE *)(a1 + 376) != 1 )
  {
    result = *(unsigned __int8 *)(a1 + 377) ^ 1u;
    if ( *(_BYTE *)(a1 + 377) != 1 )
    {
      if ( *(unsigned __int8 *)(a1 + 361) >= (unsigned int)*(_WORD *)v7
        || (result = *(unsigned __int8 *)(a1 + 361), !(_BYTE)result) )
      {
        ++*(_BYTE *)(a1 + 360);
        *(_BYTE *)(a1 + 361) = *(_BYTE *)(a1 + 379);
        *(_BYTE *)(a1 + 379) = 0;
        return sub_5588FFEDCB2B(a1);
      }
    }
  }
  return result;
}
// 5588FFEDCB2B: using guessed type __int64 __fastcall sub_5588FFEDCB2B(_QWORD);

//----- (00005588FFEDE5D2) ----------------------------------------------------
float *__fastcall sub_5588FFEDE5D2(__int64 a1, __int64 a2, float *a3, float *a4, __m128i a5)
{
  float *result; // rax
  unsigned __int16 v8; // [rsp+2Ah] [rbp-6h]
  unsigned __int8 i; // [rsp+2Fh] [rbp-1h]

  if ( *(_BYTE *)(a2 + 48) > 1u )
  {
    if ( *(_BYTE *)(a2 + 54) )
    {
      v8 = *(_WORD *)(a2 + 4LL * *(unsigned __int8 *)(a2 + 51));
      if ( *(_WORD *)a3 >= v8 )
        *(_WORD *)a3 -= v8 - *(_WORD *)(a2 + 4LL * *(unsigned __int8 *)(a2 + 50));
    }
    for ( i = 0;
          i < *(unsigned __int8 *)(a2 + 48) - 2
       && (*(_WORD *)a3 < *(_WORD *)(a2 + 4LL * i) || *(_WORD *)(a2 + 4LL * (i + 1)) < *(_WORD *)a3);
          ++i )
    {
      ;
    }
    *(double *)a5.m128i_i64 = sub_5588FFEDCA51(a2 + 4LL * i, a2 + 4 * (i + 1LL), *(unsigned __int16 *)a3);
    *a4 = COERCE_FLOAT(_mm_cvtsi128_si32(a5)) / 64.0;
    if ( *(_BYTE *)(a1 + 62) != 1
      || *(_BYTE *)(a2 + 53) != 1
      || (result = (float *)*(unsigned __int16 *)(a2 + 4LL * *(unsigned __int8 *)(a2 + 49)),
          *(_WORD *)a3 != (_WORD)result) )
    {
      result = a3;
      ++*(_WORD *)a3;
    }
  }
  else
  {
    result = (float *)*(unsigned __int8 *)(a2 + 48);
    if ( (_BYTE)result == 1 )
    {
      *a4 = (float)*(unsigned __int16 *)(a2 + 2) / 64.0;
      result = a4;
      if ( *a4 > 1.0 )
      {
        result = a4;
        *a4 = 1.0;
      }
    }
  }
  return result;
}
// 5588FFEDCA51: using guessed type double __fastcall sub_5588FFEDCA51(_QWORD, _QWORD, _QWORD);

//----- (00005588FFEDE7CE) ----------------------------------------------------
float *__fastcall sub_5588FFEDE7CE(__int64 a1, __m128i a2)
{
  float *result; // rax

  result = *(float **)(a1 + 8);
  if ( result )
  {
    if ( *(_BYTE *)(*(_QWORD *)(a1 + 8) + 174LL) )
    {
      if ( *(_BYTE *)(a1 + 62) != 1 )
      {
        *(float *)(a1 + 64) = *(float *)(a1 + 64)
                            - (float)((float)*(unsigned __int16 *)(*(_QWORD *)(a1 + 8) + 244LL) / 65536.0);
        a2 = 0LL;
        if ( *(float *)(a1 + 64) < 0.0 )
        {
          a2 = 0LL;
          *(_DWORD *)(a1 + 64) = 0;
        }
      }
      sub_5588FFEDE5D2(a1, *(_QWORD *)(a1 + 8) + 122LL, (float *)(a1 + 76), (float *)(a1 + 68), a2);
    }
    result = (float *)*(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + 230LL);
    if ( (_BYTE)result )
      return sub_5588FFEDE5D2(a1, *(_QWORD *)(a1 + 8) + 178LL, (float *)(a1 + 78), (float *)(a1 + 72), a2);
  }
  return result;
}

//----- (00005588FFEDE8D5) ----------------------------------------------------
__int64 __fastcall sub_5588FFEDE8D5(__int64 a1, __m128i a2)
{
  unsigned __int16 v2; // ax
  __m128i v3; // xmm4
  __m128i v4; // xmm5
  unsigned __int16 v5; // ax
  unsigned __int16 v6; // ax
  char v7; // al
  int v8; // eax
  float v9; // xmm3_4
  __int64 result; // rax
  char v11; // [rsp+1Fh] [rbp-21h]
  __int64 v12; // [rsp+28h] [rbp-18h]
  float v13; // [rsp+34h] [rbp-Ch]
  float v14; // [rsp+34h] [rbp-Ch]
  float v15; // [rsp+38h] [rbp-8h]
  unsigned __int8 v16; // [rsp+3Fh] [rbp-1h]

  if ( !*(_WORD *)(a1 + 362) )
    sub_5588FFEDE2E1(a1, a2);
  v16 = 0;
  while ( 2 )
  {
    if ( v16 < (unsigned int)*(_WORD *)(a1 + 54) )
    {
      v12 = *(_QWORD *)(a1 + 400) + 312LL * v16;
      sub_5588FFEDE7CE(v12, a2);
      sub_5588FFEDC362(a1, v12);
      if ( *(_BYTE *)(v12 + 84) && (*(_BYTE *)(*(_QWORD *)(v12 + 24) + 3LL) || !*(_BYTE *)(*(_QWORD *)(v12 + 24) + 4LL)) )
      {
        *(_BYTE *)(v12 + 84) = 0;
        *(_BYTE *)(v12 + 85) = 0;
        sub_5588FFEDD04C(a1, v12);
      }
      if ( *(_BYTE *)(v12 + 108)
        && *(_BYTE *)(*(_QWORD *)(v12 + 24) + 3LL) != 4
        && *(_BYTE *)(*(_QWORD *)(v12 + 24) + 4LL) != 6
        && *(_BYTE *)(*(_QWORD *)(v12 + 24) + 2LL) >> 4 != 11 )
      {
        *(_BYTE *)(v12 + 108) = 0;
        a2 = 0LL;
        *(_DWORD *)(v12 + 120) = 0;
        sub_5588FFEDD04C(a1, v12);
      }
      switch ( *(_BYTE *)(*(_QWORD *)(v12 + 24) + 2LL) >> 4 )
      {
        case 6:
          if ( *(_WORD *)(a1 + 362) )
            sub_5588FFEDC95D(v12, *(_BYTE *)(*(_QWORD *)(v12 + 24) + 2LL) & 0xF);
          break;
        case 7:
          if ( *(_WORD *)(a1 + 362) )
            sub_5588FFEDC95D(v12, (unsigned __int8)(16 * *(_BYTE *)(*(_QWORD *)(v12 + 24) + 2LL)));
          break;
        case 11:
          if ( *(_WORD *)(a1 + 362) )
          {
            *(_BYTE *)(v12 + 108) = 0;
            v2 = *(_WORD *)(v12 + 118);
            *(_WORD *)(v12 + 118) = v2 + 1;
            sub_5588FFEDC4A9(a1, v12, *(unsigned __int8 *)(v12 + 117), v2);
          }
          break;
        case 13:
          if ( *(_WORD *)(a1 + 362) )
            sub_5588FFEDC869(v12, *(_BYTE *)(*(_QWORD *)(v12 + 24) + 2LL) & 0xF);
          break;
        case 14:
          if ( *(_WORD *)(a1 + 362) )
            sub_5588FFEDC869(v12, (unsigned __int8)(16 * *(_BYTE *)(*(_QWORD *)(v12 + 24) + 2LL)));
          break;
        case 15:
          if ( *(_WORD *)(a1 + 362) )
            sub_5588FFEDC660(a1, v12);
          break;
        default:
          break;
      }
      switch ( *(_BYTE *)(*(_QWORD *)(v12 + 24) + 3LL) )
      {
        case 0:
          if ( !*(_BYTE *)(*(_QWORD *)(v12 + 24) + 4LL) )
            goto LABEL_94;
          v11 = *(_WORD *)(a1 + 340) % 3u;
          if ( v11 == 2 )
          {
            if ( *(_WORD *)(a1 + 362) == 1 )
            {
              *(_BYTE *)(v12 + 84) = 1;
              *(_BYTE *)(v12 + 85) = *(_BYTE *)(*(_QWORD *)(v12 + 24) + 4LL) >> 4;
              sub_5588FFEDD04C(a1, v12);
              goto LABEL_94;
            }
          }
          else
          {
            if ( v11 > 2 )
              goto LABEL_94;
            if ( !v11 )
              goto LABEL_37;
            if ( v11 != 1 )
              goto LABEL_94;
          }
          if ( !*(_WORD *)(a1 + 362) )
          {
            *(_BYTE *)(v12 + 84) = 0;
            *(_BYTE *)(v12 + 85) = 0;
            sub_5588FFEDD04C(a1, v12);
            goto LABEL_94;
          }
LABEL_37:
          sub_5588FFEDC5B5(
            a1,
            v12,
            *(unsigned __int8 *)(*(_QWORD *)(v12 + 24) + 4LL),
            (unsigned __int16)(*(_WORD *)(a1 + 362) - v11));
          goto LABEL_94;
        case 1:
          if ( *(_WORD *)(a1 + 362) )
          {
            v3 = 0LL;
            *(float *)v3.m128i_i32 = (float)-*(unsigned __int8 *)(v12 + 90);
            sub_5588FFEDC7E7(a1, v12, *(double *)_mm_cvtsi32_si128(_mm_cvtsi128_si32(v3)).m128i_i64);
          }
          goto LABEL_94;
        case 2:
          if ( *(_WORD *)(a1 + 362) )
          {
            v4 = 0LL;
            *(float *)v4.m128i_i32 = (float)*(unsigned __int8 *)(v12 + 91);
            sub_5588FFEDC7E7(a1, v12, *(double *)_mm_cvtsi32_si128(_mm_cvtsi128_si32(v4)).m128i_i64);
          }
          goto LABEL_94;
        case 3:
          if ( *(_WORD *)(a1 + 362) )
            sub_5588FFEDC660(a1, v12);
          goto LABEL_94;
        case 4:
          if ( *(_WORD *)(a1 + 362) )
          {
            *(_BYTE *)(v12 + 108) = 1;
            v5 = *(_WORD *)(v12 + 118);
            *(_WORD *)(v12 + 118) = v5 + 1;
            sub_5588FFEDC4A9(a1, v12, *(unsigned __int8 *)(v12 + 117), v5);
          }
          goto LABEL_94;
        case 5:
          if ( *(_WORD *)(a1 + 362) )
          {
            sub_5588FFEDC660(a1, v12);
            sub_5588FFEDC95D(v12, *(unsigned __int8 *)(v12 + 86));
          }
          goto LABEL_94;
        case 6:
          if ( *(_WORD *)(a1 + 362) )
          {
            *(_BYTE *)(v12 + 108) = 1;
            v6 = *(_WORD *)(v12 + 118);
            *(_WORD *)(v12 + 118) = v6 + 1;
            sub_5588FFEDC4A9(a1, v12, *(unsigned __int8 *)(v12 + 117), v6);
            sub_5588FFEDC95D(v12, *(unsigned __int8 *)(v12 + 86));
          }
          goto LABEL_94;
        case 7:
          if ( *(_WORD *)(a1 + 362) )
          {
            v7 = *(_BYTE *)(v12 + 130);
            *(_BYTE *)(v12 + 130) = v7 + 1;
            sub_5588FFEDC531(a2, a1, v12, *(_BYTE *)(v12 + 129), v7);
          }
          goto LABEL_94;
        case 0xA:
          if ( *(_WORD *)(a1 + 362) )
            sub_5588FFEDC95D(v12, *(unsigned __int8 *)(v12 + 86));
          goto LABEL_94;
        case 0xE:
          v8 = *(_BYTE *)(*(_QWORD *)(v12 + 24) + 4LL) >> 4;
          if ( v8 == 13 )
          {
            if ( *(unsigned __int8 *)(v12 + 105) == *(_WORD *)(a1 + 362) )
            {
              sub_5588FFEDD106(a1, v12, *(unsigned __int8 **)(v12 + 24), a2);
              sub_5588FFEDE7CE(v12, a2);
            }
          }
          else if ( (unsigned __int8)(*(_BYTE *)(*(_QWORD *)(v12 + 24) + 4LL) >> 4) <= 0xDu )
          {
            if ( v8 == 9 )
            {
              if ( *(_WORD *)(a1 + 362)
                && (*(_BYTE *)(*(_QWORD *)(v12 + 24) + 4LL) & 0xF) != 0
                && !(*(unsigned __int16 *)(a1 + 362) % (*(_BYTE *)(*(_QWORD *)(v12 + 24) + 4LL) & 0xF)) )
              {
                sub_5588FFEDE0B4(a1, v12, 0);
                sub_5588FFEDE7CE(v12, a2);
              }
            }
            else if ( v8 == 12 && (*(_BYTE *)(*(_QWORD *)(v12 + 24) + 4LL) & 0xF) == *(_WORD *)(a1 + 362) )
            {
              sub_5588FFEDE283(v12);
            }
          }
          goto LABEL_94;
        case 0x11:
          if ( *(_WORD *)(a1 + 362) && ((*(_BYTE *)(v12 + 88) & 0xF0) == 0 || (*(_BYTE *)(v12 + 88) & 0xF) == 0) )
          {
            if ( (*(_BYTE *)(v12 + 88) & 0xF0) != 0 )
            {
              *(float *)(a1 + 344) = *(float *)(a1 + 344) + (float)((float)(*(_BYTE *)(v12 + 88) >> 4) / 64.0);
              if ( *(float *)(a1 + 344) > 1.0 )
                *(_DWORD *)(a1 + 344) = 1065353216;
            }
            else
            {
              *(float *)(a1 + 344) = *(float *)(a1 + 344) - (float)((float)(*(_BYTE *)(v12 + 88) & 0xF) / 64.0);
              if ( *(float *)(a1 + 344) < 0.0 )
                *(_DWORD *)(a1 + 344) = 0;
            }
          }
          goto LABEL_94;
        case 0x14:
          if ( *(_WORD *)(a1 + 362) == *(unsigned __int8 *)(*(_QWORD *)(v12 + 24) + 4LL) )
            sub_5588FFEDE29B(v12);
          goto LABEL_94;
        case 0x19:
          if ( *(_WORD *)(a1 + 362) )
            sub_5588FFEDC869(v12, *(unsigned __int8 *)(v12 + 89));
          goto LABEL_94;
        case 0x1B:
          if ( *(_WORD *)(a1 + 362)
            && (*(_BYTE *)(v12 + 104) & 0xF) != 0
            && !(*(unsigned __int16 *)(a1 + 362) % (*(_BYTE *)(v12 + 104) & 0xF)) )
          {
            v15 = flt_5588FFEE2060[*(_BYTE *)(v12 + 104) >> 4]
                + (float)(*(float *)(v12 + 52) * flt_5588FFEE20A0[*(_BYTE *)(v12 + 104) >> 4]);
            if ( v15 <= 1.0 )
            {
              if ( v15 < 0.0 )
                v15 = 0.0;
            }
            else
            {
              v15 = 1.0;
            }
            sub_5588FFEDE0B4(a1, v12, 0);
            *(float *)(v12 + 52) = v15;
          }
          goto LABEL_94;
        case 0x1D:
          if ( *(_WORD *)(a1 + 362) )
            *(_BYTE *)(v12 + 137) = (*(unsigned __int16 *)(a1 + 362) - 1)
                                  % ((*(_BYTE *)(v12 + 136) >> 4) + (*(_BYTE *)(v12 + 136) & 0xF) + 2) > *(_BYTE *)(v12 + 136) >> 4;
          goto LABEL_94;
        default:
LABEL_94:
          v9 = fabs(*(float *)(v12 + 56) - 0.5);
          if ( *(_BYTE *)(v12 + 137) )
          {
            v13 = 0.0;
          }
          else
          {
            v14 = *(float *)(v12 + 132) + *(float *)(v12 + 52);
            if ( v14 <= 1.0 )
            {
              if ( v14 < 0.0 )
                v14 = 0.0;
            }
            else
            {
              v14 = 1.0;
            }
            v13 = (float)(*(float *)(v12 + 68) * *(float *)(v12 + 64)) * v14;
          }
          *(float *)(v12 + 156) = (float)((float)((float)(0.5 - v9) * (float)(*(float *)(v12 + 72) - 0.5))
                                        + (float)((float)(0.5 - v9) * (float)(*(float *)(v12 + 72) - 0.5)))
                                + *(float *)(v12 + 56);
          a2 = (__m128i)LODWORD(v13);
          *(float *)(v12 + 160) = v13;
          ++v16;
          continue;
      }
    }
    break;
  }
  if ( (unsigned __int16)++*(_WORD *)(a1 + 362) >= *(unsigned __int16 *)(a1 + 340) + *(unsigned __int16 *)(a1 + 380) )
  {
    *(_WORD *)(a1 + 362) = 0;
    *(_WORD *)(a1 + 380) = 0;
  }
  result = a1;
  *(float *)(a1 + 364) = (float)((float)*(int *)(a1 + 336) / (float)(0.40000001 * (float)*(unsigned __int16 *)(a1 + 342)))
                       + *(float *)(a1 + 364);
  return result;
}
// 5588FFEDC362: using guessed type __int64 __fastcall sub_5588FFEDC362(_QWORD, _QWORD);
// 5588FFEDC4A9: using guessed type __int64 __fastcall sub_5588FFEDC4A9(_QWORD, _QWORD, _QWORD, _QWORD);
// 5588FFEDC5B5: using guessed type __int64 __fastcall sub_5588FFEDC5B5(_QWORD, _QWORD, _QWORD, _QWORD);
// 5588FFEDC660: using guessed type __int64 __fastcall sub_5588FFEDC660(_QWORD, _QWORD);
// 5588FFEDC7E7: using guessed type __int64 __fastcall sub_5588FFEDC7E7(_QWORD, _QWORD, double);
// 5588FFEDC869: using guessed type __int64 __fastcall sub_5588FFEDC869(_QWORD, _QWORD);
// 5588FFEDC95D: using guessed type __int64 __fastcall sub_5588FFEDC95D(_QWORD, _QWORD);
// 5588FFEDE283: using guessed type __int64 __fastcall sub_5588FFEDE283(_QWORD);
// 5588FFEDE29B: using guessed type __int64 __fastcall sub_5588FFEDE29B(_QWORD);
// 5588FFEE2060: using guessed type float flt_5588FFEE2060[16];
// 5588FFEE20A0: using guessed type float flt_5588FFEE20A0[16];

//----- (00005588FFEDF5E3) ----------------------------------------------------
float __fastcall sub_5588FFEDF5E3(__int64 a1)
{
  __int64 v1; // rax
  float v2; // xmm0_4
  __int64 v3; // rdx
  unsigned int v5; // eax
  float v6; // xmm0_4
  __int64 v7; // rax
  float v8; // xmm0_4
  __int64 v9; // rdx
  float v10; // xmm0_4
  __int64 v11; // rax
  float v12; // xmm0_4
  __int64 v13; // rdx
  float v14; // [rsp+14h] [rbp-14h]
  unsigned int v15; // [rsp+18h] [rbp-10h]
  unsigned int v16; // [rsp+1Ch] [rbp-Ch]
  float v17; // [rsp+20h] [rbp-8h]
  float v18; // [rsp+24h] [rbp-4h]

  if ( *(_QWORD *)(a1 + 8) && *(_QWORD *)(a1 + 16) && *(float *)(a1 + 32) >= 0.0 )
  {
    if ( *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24LL) )
    {
      v16 = (int)*(float *)(a1 + 32);
      v15 = v16 + 1;
      v14 = *(float *)(a1 + 32) - (float)(int)v16;
      v18 = *(float *)(4LL * v16 + *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72LL));
      v5 = *(_DWORD *)(*(_QWORD *)(a1 + 16) + 48LL);
      if ( v5 == 2 )
      {
        if ( *(_BYTE *)(a1 + 48) )
          v8 = *(float *)(a1 + 44) + *(float *)(a1 + 32);
        else
          v8 = *(float *)(a1 + 32) - *(float *)(a1 + 44);
        *(float *)(a1 + 32) = v8;
        if ( *(_BYTE *)(a1 + 48) )
        {
          if ( v15 < *(_DWORD *)(*(_QWORD *)(a1 + 16) + 36LL) )
            v9 = 4LL * v15;
          else
            v9 = 4LL * v16;
          v17 = *(float *)(v9 + *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72LL));
          if ( *(float *)(a1 + 32) >= (float)*(int *)(*(_QWORD *)(a1 + 16) + 36LL) )
          {
            *(_BYTE *)(a1 + 48) = 0;
            *(float *)(a1 + 32) = (float)(2 * *(_DWORD *)(*(_QWORD *)(a1 + 16) + 36LL)) - *(float *)(a1 + 32);
          }
          if ( *(float *)(a1 + 32) >= (float)*(int *)(*(_QWORD *)(a1 + 16) + 24LL) )
          {
            *(_BYTE *)(a1 + 48) = 0;
            *(float *)(a1 + 32) = *(float *)(a1 + 32) - (float)(*(_DWORD *)(*(_QWORD *)(a1 + 16) + 24LL) - 1);
          }
        }
        else
        {
          v17 = v18;
          if ( v16 && *(_DWORD *)(*(_QWORD *)(a1 + 16) + 28LL) < v16 - 1 )
            v10 = *(float *)(4LL * (v16 - 1) + *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72LL));
          else
            v10 = *(float *)(4LL * v16 + *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72LL));
          v18 = v10;
          if ( (float)*(int *)(*(_QWORD *)(a1 + 16) + 28LL) >= *(float *)(a1 + 32) )
          {
            *(_BYTE *)(a1 + 48) = 1;
            *(float *)(a1 + 32) = (float)(2 * *(_DWORD *)(*(_QWORD *)(a1 + 16) + 28LL)) - *(float *)(a1 + 32);
          }
          if ( *(float *)(a1 + 32) <= 0.0 )
          {
            *(_BYTE *)(a1 + 48) = 1;
            *(_DWORD *)(a1 + 32) = 0;
          }
        }
      }
      else if ( v5 > 2 )
      {
        v17 = 0.0;
      }
      else if ( v5 )
      {
        if ( v15 == *(_DWORD *)(*(_QWORD *)(a1 + 16) + 36LL) )
          v7 = 4LL * *(unsigned int *)(*(_QWORD *)(a1 + 16) + 28LL);
        else
          v7 = 4LL * v15;
        v17 = *(float *)(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 72LL) + v7);
        for ( *(float *)(a1 + 32) = *(float *)(a1 + 44) + *(float *)(a1 + 32);
              *(float *)(a1 + 32) >= (float)*(int *)(*(_QWORD *)(a1 + 16) + 36LL);
              *(float *)(a1 + 32) = *(float *)(a1 + 32) - (float)*(int *)(*(_QWORD *)(a1 + 16) + 32LL) )
        {
          ;
        }
      }
      else
      {
        if ( v15 >= *(_DWORD *)(*(_QWORD *)(a1 + 16) + 24LL) )
          v6 = 0.0;
        else
          v6 = *(float *)(4LL * v15 + *(_QWORD *)(*(_QWORD *)(a1 + 16) + 72LL));
        v17 = v6;
        *(float *)(a1 + 32) = *(float *)(a1 + 44) + *(float *)(a1 + 32);
        if ( *(float *)(a1 + 32) >= (float)*(int *)(*(_QWORD *)(a1 + 16) + 24LL) )
          *(_DWORD *)(a1 + 32) = -1082130432;
      }
      if ( *(_QWORD *)(a1 + 168) > 0x1FuLL )
      {
        return (float)((float)(v17 - v18) * v14) + v18;
      }
      else
      {
        v11 = *(_QWORD *)(a1 + 168);
        if ( v11 < 0 )
        {
          v13 = *(_QWORD *)(a1 + 168) & 1LL | ((unsigned __int64)v11 >> 1);
          v12 = (float)(int)v13 + (float)(int)v13;
        }
        else
        {
          v12 = (float)(int)v11;
        }
        return (float)((float)((float)((float)((float)(v17 - v18) * v14) + v18)
                             - *(float *)(a1 + 4 * (*(_QWORD *)(a1 + 168) + 44LL)))
                     * (float)(v12 / 32.0))
             + *(float *)(a1 + 4 * (*(_QWORD *)(a1 + 168) + 44LL));
      }
    }
    else
    {
      return 0.0;
    }
  }
  else if ( *(_QWORD *)(a1 + 168) > 0x1FuLL )
  {
    return 0.0;
  }
  else
  {
    v1 = *(_QWORD *)(a1 + 168);
    if ( v1 < 0 )
    {
      v3 = *(_QWORD *)(a1 + 168) & 1LL | ((unsigned __int64)v1 >> 1);
      v2 = (float)(int)v3 + (float)(int)v3;
    }
    else
    {
      v2 = (float)(int)v1;
    }
    return (float)((float)(0.0 - *(float *)(a1 + 4 * (*(_QWORD *)(a1 + 168) + 44LL))) * (float)(v2 / 32.0))
         + *(float *)(a1 + 4 * (*(_QWORD *)(a1 + 168) + 44LL));
  }
}
// 5588FFEDF774: conditional instruction was optimized away because eax.4==1

//----- (00005588FFEDFD07) ----------------------------------------------------
float *__fastcall sub_5588FFEDFD07(__int64 a1, float *a2, float *a3)
{
  float *result; // rax
  __m128i v4; // xmm0
  float v6; // [rsp+2Ch] [rbp-14h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  float v8; // [rsp+38h] [rbp-8h]
  unsigned __int8 i; // [rsp+3Fh] [rbp-1h]

  if ( *(float *)(a1 + 364) <= 0.0 )
    sub_5588FFEDE8D5(a1, (__m128i)0LL);
  *(float *)(a1 + 364) = *(float *)(a1 + 364) - 1.0;
  *a2 = 0.0;
  *a3 = 0.0;
  if ( !*(_BYTE *)(a1 + 393)
    || (result = (float *)*(unsigned __int8 *)(a1 + 393), *(_BYTE *)(a1 + 392) < (unsigned __int8)result) )
  {
    for ( i = 0; i < (unsigned int)*(_WORD *)(a1 + 54); ++i )
    {
      v7 = *(_QWORD *)(a1 + 400) + 312LL * i;
      if ( *(_QWORD *)(v7 + 8) )
      {
        if ( *(_QWORD *)(v7 + 16) )
        {
          v4 = 0LL;
          if ( *(float *)(v7 + 32) >= 0.0 )
          {
            *(float *)v4.m128i_i32 = sub_5588FFEDF5E3(v7);
            v6 = COERCE_FLOAT(_mm_cvtsi128_si32(v4));
            if ( *(_BYTE *)(v7 + 152) != 1 && *(_BYTE *)(*(_QWORD *)(v7 + 8) + 256LL) != 1 )
            {
              *a2 = (float)((float)(1.0 - *(float *)(v7 + 304)) * (float)(*(float *)(v7 + 308) * v6)) + *a2;
              *a3 = (float)(*(float *)(v7 + 304) * (float)(*(float *)(v7 + 308) * v6)) + *a3;
            }
            ++*(_QWORD *)(v7 + 168);
            if ( *(float *)(v7 + 308) <= *(float *)(v7 + 160) )
            {
              if ( *(float *)(v7 + 160) > *(float *)(v7 + 308) )
              {
                *(float *)(v7 + 308) = *(float *)(a1 + 352) + *(float *)(v7 + 308);
                if ( *(float *)(v7 + 308) > *(float *)(v7 + 160) )
                  *(_DWORD *)(v7 + 308) = *(_DWORD *)(v7 + 160);
              }
            }
            else
            {
              *(float *)(v7 + 308) = *(float *)(v7 + 308) - *(float *)(a1 + 352);
              if ( *(float *)(v7 + 160) > *(float *)(v7 + 308) )
                *(_DWORD *)(v7 + 308) = *(_DWORD *)(v7 + 160);
            }
            if ( *(float *)(v7 + 304) <= *(float *)(v7 + 156) )
            {
              if ( *(float *)(v7 + 156) > *(float *)(v7 + 304) )
              {
                *(float *)(v7 + 304) = *(float *)(a1 + 356) + *(float *)(v7 + 304);
                if ( *(float *)(v7 + 304) > *(float *)(v7 + 156) )
                  *(_DWORD *)(v7 + 304) = *(_DWORD *)(v7 + 156);
              }
            }
            else
            {
              *(float *)(v7 + 304) = *(float *)(v7 + 304) - *(float *)(a1 + 356);
              if ( *(float *)(v7 + 156) > *(float *)(v7 + 304) )
                *(_DWORD *)(v7 + 304) = *(_DWORD *)(v7 + 156);
            }
          }
        }
      }
    }
    v8 = *(float *)(a1 + 348) * *(float *)(a1 + 344);
    *a2 = *a2 * v8;
    result = a3;
    *a3 = *a3 * v8;
  }
  return result;
}

//----- (00005588FFEE0138) ----------------------------------------------------
unsigned __int64 __fastcall sub_5588FFEE0138(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 i; // [rsp+28h] [rbp-8h]

  if ( a1 && a2 )
  {
    *(_QWORD *)(a1 + 368) += a3;
    for ( i = 0LL; ; ++i )
    {
      result = i;
      if ( i >= a3 )
        break;
      sub_5588FFEDFD07(a1, (float *)(a2 + 8 * i), (float *)(a2 + 8 * i + 4));
    }
  }
  return result;
}

//----- (00005588FFEE01C8) ----------------------------------------------------
unsigned __int64 __fastcall sub_5588FFEE01C8(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  float v5; // [rsp+20h] [rbp-10h] BYREF
  float v6; // [rsp+24h] [rbp-Ch] BYREF
  unsigned __int64 i; // [rsp+28h] [rbp-8h]

  if ( a1 && a2 )
  {
    *(_QWORD *)(a1 + 368) += a3;
    for ( i = 0LL; ; ++i )
    {
      result = i;
      if ( i >= a3 )
        break;
      sub_5588FFEDFD07(a1, &v6, &v5);
      *(_WORD *)(4 * i + a2) = (int)(float)(32767.0 * v6);
      *(_WORD *)(4 * i + 2 + a2) = (int)(float)(32767.0 * v5);
    }
  }
  return result;
}

//----- (00005588FFEE0298) ----------------------------------------------------
unsigned __int64 __fastcall sub_564317C10298(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 result; // rax
  float v5; // [rsp+20h] [rbp-10h] BYREF
  float v6; // [rsp+24h] [rbp-Ch] BYREF
  unsigned __int64 i; // [rsp+28h] [rbp-8h]

  if ( a1 && a2 )
  {
    *(_QWORD *)(a1 + 368) += a3;
    for ( i = 0LL; ; ++i )
    {
      result = i;
      if ( i >= a3 )
        break;
      sub_5588FFEDFD07(a1, &v6, &v5);
      *(_BYTE *)(2 * i + a2) = (int)(float)(127.0 * v6);
      *(_BYTE *)(2 * i + 1 + a2) = (int)(float)(127.0 * v5);
    }
  }
  return result;
}
// 5588FFEDFD07: using guessed type __int64 __fastcall sub_564317C0FD07(_QWORD, _QWORD, _QWORD);

//----- (00005588FFEE0361) ----------------------------------------------------
__int64 __fastcall sub_5588FFEE0361(__int64 a1)
{
  float v1; // xmm0_4
  float v2; // xmm0_4
  _BYTE v4[9]; // [rsp+17h] [rbp-9h]

  v4[8] = 0;
  *(_QWORD *)v4 = (unsigned __int8)sub_5588FFED9800(a1);
  sub_5588FFED97E2(a1, 0);
  while ( v4[0] == (unsigned __int8)sub_5588FFED9800(a1) )
  {
    if ( *(__int64 *)&v4[1] < 0 )
      v1 = (float)(int)(v4[1] & 1 | (*(_QWORD *)&v4[1] >> 1)) + (float)(int)(v4[1] & 1 | (*(_QWORD *)&v4[1] >> 1));
    else
      v1 = (float)*(int *)&v4[1];
    v2 = v1 + *(float *)(a1 + 364);
    if ( v2 >= 9.223372e18 )
      *(_QWORD *)&v4[1] = (unsigned int)(int)(float)(v2 - 9.223372e18) ^ 0x8000000000000000LL;
    else
      *(_QWORD *)&v4[1] = (unsigned int)(int)v2;
    *(_DWORD *)(a1 + 364) = 0;
    sub_5588FFEDE8D5(a1, (__m128i)0LL);
  }
  *(_BYTE *)(a1 + 392) = v4[0];
  return *(_QWORD *)&v4[1];
}

//----- (00005588FFEE045B) ----------------------------------------------------
__int64 __fastcall sub_564317C1045B(_QWORD *a1, unsigned int a2, const char *a3)
{
  int v4; // eax
  void *ptr; // [rsp+28h] [rbp-18h]
  unsigned __int64 n; // [rsp+30h] [rbp-10h]
  FILE *stream; // [rsp+38h] [rbp-8h]

  stream = fopen(a3, "rb");
  if ( !stream )
  {
    fwrite("Could not open input file", 1uLL, 0x19uLL, _bss_start);
    fflush(_bss_start);
    *a1 = 0LL;
    return 3LL;
  }
  fseek(stream, 0LL, 2);
  n = ftell(stream);
  rewind(stream);
  if ( n == 0xFFFFFFFF )
  {
    fclose(stream);
    fwrite("fseek() failed", 1uLL, 0xEuLL, _bss_start);
    fflush(_bss_start);
    *a1 = 0LL;
    return 4LL;
  }
  ptr = malloc(n + 1);
  if ( fread(ptr, 1uLL, n, stream) < n )
  {
    fclose(stream);
    fwrite("fread() failed", 1uLL, 0xEuLL, _bss_start);
    fflush(_bss_start);
    *a1 = 0LL;
    return 5LL;
  }
  fclose(stream);
  v4 = sub_5588FFED953A(a1, ptr, n, a2);
  if ( v4 == 2 )
  {
    fwrite("could not create context: malloc failed\n", 1uLL, 0x28uLL, _bss_start);
    fflush(_bss_start);
    exit(1);
  }
  if ( v4 > 2 )
    goto LABEL_13;
  if ( v4 )
  {
    if ( v4 == 1 )
    {
      fwrite("could not create context: module is not sane\n", 1uLL, 0x2DuLL, _bss_start);
      fflush(_bss_start);
      *a1 = 0LL;
      return 1LL;
    }
LABEL_13:
    fwrite("could not create context: unknown error\n", 1uLL, 0x28uLL, _bss_start);
    fflush(_bss_start);
    exit(1);
  }
  return 0LL;
}
// 5588FFED953A: using guessed type __int64 __fastcall sub_564317C0953A(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00005588FFEE06F2) ----------------------------------------------------
__int64 __fastcall load_enter_pass_image(__int64 a1, _QWORD *a2)
{
  __int64 RW; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = SDL_RWFromMem(&unk_5589000242C0, (unsigned int)dword_558900080660);
  if ( !v4 )
    return 0xFFFFFFFFLL;
  RW = IMG_Load_RW(v4, 1LL);
  if ( !RW )
    return 0xFFFFFFFFLL;
  *a2 = SDL_CreateTextureFromSurface(a1, RW);
  SDL_FreeSurface(RW);
  return *a2 == 0LL;
}
// 5588FFED90B0: using guessed type __int64 __fastcall IMG_Load_RW(_QWORD, _QWORD);
// 5588FFED9100: using guessed type __int64 __fastcall SDL_FreeSurface(_QWORD);
// 5588FFED9160: using guessed type __int64 __fastcall SDL_RWFromMem(_QWORD, _QWORD);
// 5588FFED9260: using guessed type __int64 __fastcall SDL_CreateTextureFromSurface(_QWORD, _QWORD);
// 558900080660: using guessed type int dword_55F292C26660;

//----- (00005588FFEE078E) ----------------------------------------------------
__int64 __fastcall load_lose_image(__int64 a1, _QWORD *a2)
{
  __int64 RW; // [rsp+10h] [rbp-10h]
  __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = SDL_RWFromMem(&unk_558900080680, (unsigned int)dword_5589000E5690);
  if ( !v4 )
    return 0xFFFFFFFFLL;
  RW = IMG_Load_RW(v4, 1LL);
  if ( !RW )
    return 0xFFFFFFFFLL;
  *a2 = SDL_CreateTextureFromSurface(a1, RW);
  SDL_FreeSurface(RW);
  return *a2 == 0LL;
}
// 5588FFED90B0: using guessed type __int64 __fastcall IMG_Load_RW(_QWORD, _QWORD);
// 5588FFED9100: using guessed type __int64 __fastcall SDL_FreeSurface(_QWORD);
// 5588FFED9160: using guessed type __int64 __fastcall SDL_RWFromMem(_QWORD, _QWORD);
// 5588FFED9260: using guessed type __int64 __fastcall SDL_CreateTextureFromSurface(_QWORD, _QWORD);
// 5589000E5690: using guessed type int dword_55F292C8B690;

//----- (00005588FFEE082A) ----------------------------------------------------
__int64 __fastcall sub_982A(__int64 renderer, _QWORD *a2, char *hash)
{
  __int64 aes25_glag; // rax
  unsigned int v6; // [rsp+2Ch] [rbp-44h] BYREF
  __int64 iv[3]; // [rsp+30h] [rbp-40h] BYREF
  __int64 RW; // [rsp+48h] [rbp-28h]
  __int64 v9; // [rsp+50h] [rbp-20h]
  unsigned int v10; // [rsp+5Ch] [rbp-14h]
  __int64 aes256_ctx; // [rsp+60h] [rbp-10h]
  void *ptr; // [rsp+68h] [rbp-8h]

  iv[0] = 0LL;
  iv[1] = 0LL;
  ptr = malloc((unsigned int)size);
  if ( !ptr )
    return 0xFFFFFFFFLL;
  aes256_ctx = EVP_CIPHER_CTX_new();
  if ( aes256_ctx )
  {
    aes25_glag = EVP_aes_256_cbc();
    if ( (unsigned int)EVP_DecryptInit_ex(aes256_ctx, aes25_glag, 0LL, hash, iv) == 1 )
    {
      v6 = 0;
      v10 = 0;
      if ( (unsigned int)EVP_DecryptUpdate(aes256_ctx, ptr, &v6, &unk_5589000E56A0, (unsigned int)size) == 1
        && (v10 = v6, (unsigned int)EVP_DecryptFinal_ex(aes256_ctx, (char *)ptr + (int)v6, &v6) == 1) )
      {
        v10 += v6;
        EVP_CIPHER_CTX_free(aes256_ctx);
        v9 = SDL_RWFromMem(ptr, v10);
        if ( v9 && (RW = IMG_Load_RW(v9, 1LL)) != 0 )
        {
          *a2 = SDL_CreateTextureFromSurface(renderer, RW);
          SDL_FreeSurface(RW);
          free(ptr);
          if ( *a2 )
            return 0LL;
          else
            return 0xFFFFFFFFLL;
        }
        else
        {
          free(ptr);
          return 0xFFFFFFFFLL;
        }
      }
      else
      {
        EVP_CIPHER_CTX_free(aes256_ctx);
        free(ptr);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      EVP_CIPHER_CTX_free(aes256_ctx);
      free(ptr);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    free(ptr);
    return 0xFFFFFFFFLL;
  }
}
// 5588FFED90B0: using guessed type __int64 __fastcall IMG_Load_RW(_QWORD, _QWORD);
// 5588FFED9100: using guessed type __int64 __fastcall SDL_FreeSurface(_QWORD);
// 5588FFED9160: using guessed type __int64 __fastcall SDL_RWFromMem(_QWORD, _QWORD);
// 5588FFED9210: using guessed type __int64 EVP_aes_256_cbc(void);
// 5588FFED9240: using guessed type __int64 __fastcall EVP_DecryptFinal_ex(_QWORD, _QWORD, _QWORD);
// 5588FFED9260: using guessed type __int64 __fastcall SDL_CreateTextureFromSurface(_QWORD, _QWORD);
// 5588FFED9270: using guessed type __int64 __fastcall EVP_CIPHER_CTX_free(_QWORD);
// 5588FFED9290: using guessed type __int64 EVP_CIPHER_CTX_new(void);
// 5588FFED92C0: using guessed type __int64 __fastcall EVP_DecryptUpdate(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 5588FFED9310: using guessed type __int64 __fastcall EVP_DecryptInit_ex(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (00005588FFEE0A4C) ----------------------------------------------------
__int64 __fastcall load_sound_image(__int64 a1, _QWORD *a2, _QWORD *a3)
{
  __int64 v5; // [rsp+20h] [rbp-20h]
  __int64 RW; // [rsp+28h] [rbp-18h]
  __int64 v7; // [rsp+30h] [rbp-10h]
  __int64 v8; // [rsp+38h] [rbp-8h]

  v8 = SDL_RWFromMem(&unk_55890001FEE0, (unsigned int)sound_image1_length);
  if ( !v8 )
    return 0xFFFFFFFFLL;
  v7 = SDL_RWFromMem(&unk_558900021CC0, (unsigned int)sound_image2_length);
  if ( !v7 )
    return 0xFFFFFFFFLL;
  RW = IMG_Load_RW(v8, 1LL);
  v5 = IMG_Load_RW(v7, 1LL);
  if ( !RW || !v5 )
    return 1LL;
  *a2 = SDL_CreateTextureFromSurface(a1, RW);
  *a3 = SDL_CreateTextureFromSurface(a1, v5);
  SDL_FreeSurface(RW);
  SDL_FreeSurface(v5);
  return !a2 || !a3;
}
// 5588FFED90B0: using guessed type __int64 __fastcall IMG_Load_RW(_QWORD, _QWORD);
// 5588FFED9100: using guessed type __int64 __fastcall SDL_FreeSurface(_QWORD);
// 5588FFED9160: using guessed type __int64 __fastcall SDL_RWFromMem(_QWORD, _QWORD);
// 5588FFED9260: using guessed type __int64 __fastcall SDL_CreateTextureFromSurface(_QWORD, _QWORD);
// 558900021CAC: using guessed type int dword_55F292BC7CAC;
// 5589000242AC: using guessed type int dword_55F292BCA2AC;

//----- (00005588FFEE0B5F) ----------------------------------------------------
__int64 __fastcall sub_55F292A86B5F(_QWORD *a1, unsigned int *a2)
{
  if ( !a2 )
    return 1LL;
  if ( (unsigned int)sub_5588FFED953A(a1, aExtendedModule_0, (unsigned int)dword_55890001FEC0, *a2) )
    return 1LL;
  sub_5588FFED97E2(*a1, 0LL);
  return 0LL;
}
// 5588FFED953A: using guessed type __int64 __fastcall sub_55F292A7F53A(_QWORD, _QWORD, _QWORD, _QWORD);
// 5588FFED97E2: using guessed type __int64 __fastcall sub_55F292A7F7E2(_QWORD, _QWORD);
// 55890001FEC0: using guessed type int dword_55F292BC5EC0;

//----- (00005588FFEE0BC6) ----------------------------------------------------
_BOOL8 __fastcall load_font(_QWORD *a1)
{
  __int64 v2; // [rsp+18h] [rbp-8h]

  v2 = SDL_RWFromConstMem(&unk_5588FFEE5220, (unsigned int)dword_558900016230);
  if ( !v2 )
    return 1LL;
  *a1 = TTF_OpenFontRW(v2, 1LL, 28LL);
  return *a1 == 0LL;
}
// 5588FFED9370: using guessed type __int64 __fastcall SDL_RWFromConstMem(_QWORD, _QWORD);
// 5588FFED93A0: using guessed type __int64 __fastcall TTF_OpenFontRW(_QWORD, _QWORD, _QWORD);
// 558900016230: using guessed type int dword_55F292BBC230;

//----- (00005588FFEE0C32) ----------------------------------------------------
unsigned __int64 __fastcall find_integer_index(int a1)
{
  unsigned __int64 i; // [rsp+Ch] [rbp-8h]

  for ( i = 0LL; i <= 9; ++i )
  {
    if ( a1 == dword_5588FFEE2520[i] )
      return i;
  }
  return 0xFFFFFFFFLL;
}
// 5588FFEE2520: using guessed type _DWORD dword_5588FFEE2520[10];

//----- (00005588FFEE0C77) ----------------------------------------------------
__int64 checkCollours()
{
  int v1; // edi
  __int64 v2; // rcx
  int v3; // edx
  struct SDL_Rect arect; // [rsp+0h] [rbp-90h] BYREF
  char s[68]; // [rsp+10h] [rbp-80h] BYREF
  int v6; // [rsp+54h] [rbp-3Ch]
  __int64 *pixels; // [rsp+58h] [rbp-38h]
  struct SDL_Surface *RGBSurfaceWithFormat; // [rsp+60h] [rbp-30h]
  int y; // [rsp+68h] [rbp-28h]
  int x; // [rsp+6Ch] [rbp-24h]
  unsigned __int64 m; // [rsp+70h] [rbp-20h]
  unsigned int v12; // [rsp+7Ch] [rbp-14h]
  int k; // [rsp+80h] [rbp-10h]
  int j; // [rsp+84h] [rbp-Ch]
  char integer_index; // [rsp+8Bh] [rbp-5h]
  int i; // [rsp+8Ch] [rbp-4h]

  memset(s, 255, '@');
  for ( i = 0; i <= 63; ++i )
  {
    x = 17 * i + 60;
    y = 607;
    RGBSurfaceWithFormat = SDL_CreateRGBSurfaceWithFormat(0LL, 16LL, 32LL, 32LL, 0x16462004LL);
    if ( !RGBSurfaceWithFormat )
      return 0LL;
    v1 = (int)RGBSurfaceWithFormat->pixels;
    v2 = *(_QWORD *)&RGBSurfaceWithFormat->pixels;
    v3 = **(_DWORD **)&RGBSurfaceWithFormat->w;
    arect.x = x;
    arect.y = y;
    arect.w = 16;
    arect.h = 32;
    SDL_RenderReadPixels(renderer, &arect, v3, v2, v1);
    pixels = *(__int64 **)&RGBSurfaceWithFormat->pixels;// find a pixel color that matched
    integer_index = 0xFF;
    for ( j = 0; j <= 31; ++j )
    {
      for ( k = 0; k <= 15; ++k )
      {
        v6 = *((_DWORD *)&pixels[8 * j] + k);
        if ( integer_index == (char)0xFF )
          integer_index = find_integer_index(v6);// find !
      }
    }
    s[i] = integer_index;
    SDL_FreeSurface(RGBSurfaceWithFormat);
  }
  v12 = 1;
  for ( m = 0LL; m <= 63; ++m )
    v12 = ((unsigned __int8)s[m] == dword_5588FFEE2420[m]) & (unsigned __int8)v12;
  return v12;
}
// 5588FFED9100: using guessed type __int64 __fastcall SDL_FreeSurface(_QWORD);
// 5588FFEE2420: using guessed type _DWORD dword_5588FFEE2420[64];
// 5588FFEE0C77: using guessed type char s[68];

//----- (00005588FFEE0E2E) ----------------------------------------------------
__int64 __fastcall hash_sha256(char *data, __int64 data_length, __int64 out)
{
  __int64 v4; // rax
  char v6[4]; // [rsp+24h] [rbp-Ch] BYREF
  __int64 hash_ctx; // [rsp+28h] [rbp-8h]

  hash_ctx = EVP_MD_CTX_new();
  if ( !hash_ctx )
    return 0xFFFFFFFFLL;
  v4 = EVP_sha256();
  if ( (unsigned int)EVP_DigestInit_ex(hash_ctx, v4, 0LL) == 1
    && (unsigned int)EVP_DigestUpdate(hash_ctx, data, data_length) == 1 )
  {
    if ( (unsigned int)EVP_DigestFinal_ex(hash_ctx, out, v6) == 1 )
    {
      EVP_MD_CTX_free(hash_ctx);
      return 0LL;
    }
    else
    {
      EVP_MD_CTX_free(hash_ctx);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    EVP_MD_CTX_free(hash_ctx);
    return 0xFFFFFFFFLL;
  }
}
// 5588FFED9030: using guessed type __int64 EVP_sha256(void);
// 5588FFED9080: using guessed type __int64 __fastcall EVP_DigestUpdate(_QWORD, _QWORD, _QWORD);
// 5588FFED90A0: using guessed type __int64 EVP_MD_CTX_new(void);
// 5588FFED91A0: using guessed type __int64 __fastcall EVP_MD_CTX_free(_QWORD);
// 5588FFED92D0: using guessed type __int64 __fastcall EVP_DigestInit_ex(_QWORD, _QWORD, _QWORD);
// 5588FFED93C0: using guessed type __int64 __fastcall EVP_DigestFinal_ex(_QWORD, _QWORD, _QWORD);
// 5588FFEE0E2E: using guessed type char var_C[4];

//----- (00005588FFEE0F01) ----------------------------------------------------
void *__fastcall sub_564317C10F01(__int64 a1, void *a2, int a3)
{
  if ( qword_558900142240 )
  {
    if ( (unsigned __int16)word_558900142224 == 33056 )
      return (void *)sub_5588FFEE0138(qword_558900142240, a2, a3 / 8);
    if ( (unsigned __int16)word_558900142224 <= 0x8120u )
    {
      if ( (unsigned __int16)word_558900142224 == 32776 )
        return (void *)sub_5588FFEE0298(qword_558900142240, a2, a3 / 2);
      if ( (unsigned __int16)word_558900142224 == 32784 )
        return (void *)sub_5588FFEE01C8(qword_558900142240, a2, a3 / 4);
    }
  }
  return memset(a2, 0, a3);
}
// 5588FFEE0138: using guessed type __int64 __fastcall sub_564317C10138(_QWORD, _QWORD, _QWORD);
// 5588FFEE01C8: using guessed type __int64 __fastcall sub_564317C101C8(_QWORD, _QWORD, _QWORD);
// 5588FFEE0298: using guessed type __int64 __fastcall sub_564317C10298(_QWORD, _QWORD, _QWORD);
// 558900142224: using guessed type __int16 word_564317E72224;
// 558900142240: using guessed type __int64 qword_564317E72240;

//----- (00005588FFEE0FFB) ----------------------------------------------------
__int64 load_ressources()
{
  __int64 result; // rax

  if ( (unsigned int)load_enter_pass_image(renderer, &enter_pw_umgae)
    || (unsigned int)load_lose_image(renderer, &final_render)
    || (unsigned int)load_sound_image(renderer, &sound_image1, &sound_image2)
    || (unsigned int)load_font(&font) )
  {
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
  }
  result = (unsigned int)dword_558900142210;
  if ( dword_558900142210 )
  {
    result = sub_5588FFEE0B5F(&qword_558900142240, &unk_558900142220);
    if ( (_DWORD)result )
    {
      SDL_DestroyRenderer(renderer);
      SDL_DestroyWindow(window);
      return SDL_Quit();
    }
  }
  return result;
}
// 5588FFED90F0: using guessed type __int64 SDL_Quit(void);
// 5588FFED91D0: using guessed type __int64 __fastcall SDL_DestroyWindow(_QWORD);
// 5588FFED91F0: using guessed type __int64 __fastcall SDL_DestroyRenderer(_QWORD);
// 5588FFEE06F2: using guessed type __int64 __fastcall sub_55F292A866F2(_QWORD, _QWORD);
// 5588FFEE078E: using guessed type __int64 __fastcall sub_55F292A8678E(_QWORD, _QWORD);
// 5588FFEE0A4C: using guessed type __int64 __fastcall sub_55F292A86A4C(_QWORD, _QWORD, _QWORD);
// 5588FFEE0B5F: using guessed type __int64 __fastcall sub_55F292A86B5F(_QWORD, _QWORD);
// 5588FFEE0BC6: using guessed type __int64 __fastcall sub_55F292A86BC6(_QWORD);
// 5589001421E0: using guessed type __int64 qword_55F292CE81E0;
// 5589001421F0: using guessed type __int64 qword_55F292CE81F0;
// 5589001421F8: using guessed type __int64 final_render;
// 558900142210: using guessed type int dword_55F292CE8210;
// 558900142240: using guessed type __int64 qword_55F292CE8240;
// 558900142248: using guessed type __int64 qword_55F292CE8248;
// 558900142250: using guessed type __int64 qword_55F292CE8250;

//----- (00005588FFEE10E2) ----------------------------------------------------
int __cdecl main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // rdx
  int v4; // eax
  __int64 v6; // rdi
  __int64 v7; // rax
  size_t v8; // rax
  __int64 v9; // rax
  size_t v10; // rax
  __int64 v11; // rdi
  char user_input_hash[64]; // [rsp+10h] [rbp-130h] BYREF
  struct SDL_Rect time_rect; // [rsp+50h] [rbp-F0h] BYREF
  char time_text[8]; // [rsp+68h] [rbp-D8h] BYREF
  struct SDL_Event v15; // [rsp+70h] [rbp-D0h] BYREF
  char v16[8]; // [rsp+7Ch] [rbp-C4h] BYREF
  int v17; // [rsp+84h] [rbp-BCh]
  __int16 v18; // [rsp+88h] [rbp-B8h]
  struct SDL_Rect dst_rect; // [rsp+B0h] [rbp-90h] BYREF
  int v20; // [rsp+C0h] [rbp-80h] BYREF
  __int16 v21; // [rsp+C4h] [rbp-7Ch]
  char v22; // [rsp+C6h] [rbp-7Ah]
  __int16 v23; // [rsp+C8h] [rbp-78h]
  void *(__fastcall *v24)(__int64, void *, int); // [rsp+D0h] [rbp-70h]
  __int64 v25; // [rsp+D8h] [rbp-68h]
  char *userinput; // [rsp+E8h] [rbp-58h]
  __int64 v27; // [rsp+F0h] [rbp-50h]
  struct SDL_Surface *v28; // [rsp+F8h] [rbp-48h]
  unsigned int time_from; // [rsp+104h] [rbp-3Ch]
  struct SDL_Surface *sdl_surface_text; // [rsp+108h] [rbp-38h]
  unsigned __int64 j; // [rsp+110h] [rbp-30h]
  unsigned __int64 i; // [rsp+118h] [rbp-28h]
  int end; // [rsp+124h] [rbp-1Ch]
  __int64 TextureFromSurface; // [rsp+128h] [rbp-18h]

  if ( (unsigned int)SDL_Init(32LL, argv, envp) || (int)SDL_Init(17LL, argv, v3) < 0 || (TTF_Init(), v4 == -1) )
  {
    SDL_Quit();
    return 1;
  }
  else
  {
    window = SDL_CreateWindow("FCSC 2025 - Coloratops", 805240832LL, 805240832LL, 1200LL, 686LL, 20LL);
    if ( window )
    {
      renderer = SDL_CreateRenderer(window, 0xFFFFFFFFLL, 6LL);
      if ( renderer )
      {
        v20 = 48000;
        v21 = -32480;
        v22 = 2;
        v23 = 2048;
        v24 = sub_5588FFEE0F01;
        v25 = 0LL;
        dword_558900142210 = SDL_OpenAudioDevice(0LL, 0LL, &v20, &unk_558900142220, 11LL);
        v6 = renderer;
        load_ressources();
        SDL_StartTextInput();
        TextureFromSurface = 0LL;
        dst_rect.x = 60;
        dst_rect.y = 600;
        dst_rect.w = 100;
        dst_rect.h = 200;
        end = 1;
        ticks = SDL_GetTicks(v6, &font);
        while ( end )
        {
          while ( (unsigned int)SDL_PollEvent(&v15) )
          {
            switch ( v15.type )
            {
              case 0x100:                       // quit
                end = 0;
                break;
              case 0x303:                       // text_input
                for ( i = 0LL; ; ++i )
                {
                  v8 = strlen(v16);
                  if ( i >= v8 )
                    break;
                  if ( (unsigned __int64)user_input_length <= 63
                    && strchr("FCSC{}abcdef0123456789", v16[i])
                    && (unsigned __int64)user_input_length <= 254 )
                  {
                    v7 = user_input_length++;
                    user_input[v7] = v16[i];
                    user_input[user_input_length] = 0;
                  }
                }
                break;
              case 0x300:                       // keydown
                if ( v17 == '\b' && (v18 & 0xC0) == 0 && user_input_length )
                {
                  user_input[--user_input_length] = 0;
                }
                else if ( v17 == 'q' && (v18 & 0xC0) != 0 )
                {
                  end = 0;
                }
                else if ( v17 == 'c' && (v18 & 0xC0) != 0 || v17 == '\b' && (v18 & 0xC0) != 0 || v17 == 27 )
                {
                  memset(user_input, 0, 0x100uLL);
                  user_input_length = 0LL;
                }
                else if ( v17 == ' ' )
                {
                  dword_558900142374 ^= 1u;
                  SDL_PauseAudioDevice((unsigned int)dword_558900142210, dword_558900142374 == 0);
                }
                else if ( v17 == 'v' && (v18 & 0xC0) != 0 )
                {
                  userinput = (char *)SDL_GetClipboardText();
                  if ( userinput )
                  {
                    for ( j = 0LL; ; ++j )
                    {
                      v10 = strlen(userinput);
                      if ( j >= v10 )
                        break;
                      if ( (unsigned __int64)user_input_length <= 63
                        && strchr("FCSC{}abcdef0123456789", userinput[j])
                        && (unsigned __int64)user_input_length <= 254 )
                      {
                        v9 = user_input_length++;
                        user_input[v9] = userinput[j];
                        user_input[user_input_length] = 0;
                      }
                    }
                    SDL_free(userinput);
                  }
                }
                break;
            }
          }
          dword_558900142368 = user_input[4] == '{'
                            && user_input[3] == 'C'
                            && user_input[2] == 'S'
                            && user_input[1] == 'C'
                            && user_input[0] == 'F';
          LOBYTE(dword_558900142368) = user_input[user_input_length - 1] == '}'
                                    && user_input[4] == '{'
                                    && user_input[3] == 'C'
                                    && user_input[2] == 'S'
                                    && user_input[1] == 'C'
                                    && user_input[0] == 'F';
          dword_558900142368 = (unsigned __int8)dword_558900142368;
          dword_558900142368 &= checkCollours();
          if ( TextureFromSurface )
            SDL_DestroyTexture(TextureFromSurface);
          if ( !counter_finished )
          {
            sdl_surface_text = TTF_RenderText_Blended(font, user_input, 0xFFFFFFFFLL);
            if ( sdl_surface_text )
            {
              TextureFromSurface = SDL_CreateTextureFromSurface(renderer, sdl_surface_text);
              dst_rect.w = sdl_surface_text->pitch;
              dst_rect.h = *(&sdl_surface_text->pitch + 1);
              SDL_FreeSurface(sdl_surface_text);
            }
          }
          SDL_SetRenderDrawColor(renderer, 0LL, 0LL, 0LL, 255LL);
          v11 = renderer;
          SDL_RenderClear(renderer);
          time_from = ((unsigned int)SDL_GetTicks(v11, 0LL) - ticks) / 1000;
          if ( time_from > 4294967278 && !counter_finished )
            counter_finished = 1;
          if ( counter_finished )
          {
            SDL_RenderCopy(renderer, final_render, 0LL, (__int64)&sdl_rect_1);
          }
          else if ( dword_558900142368 )
          {
            hash_sha256(user_input, user_input_length, (__int64)user_input_hash);
            if ( !qword_558900142200 )
              decryptImage(renderer, &qword_558900142200, user_input_hash);
            SDL_RenderCopy(renderer, qword_558900142200, 0LL, (__int64)&sdl_rect_1);
          }
          else
          {
            SDL_RenderCopy(renderer, enter_pw_umgae, 0LL, (__int64)&sdl_rect_1);
          }
          if ( dword_558900142374 )
            SDL_RenderCopy(renderer, sound_image1, 0LL, (__int64)&unk_5588FFEE2400);
          else
            SDL_RenderCopy(renderer, sound_image2, 0LL, (__int64)&unk_5588FFEE2400);
          if ( !counter_finished )              // print countteer if still running
          {
            snprintf(time_text, 8uLL, "%2d ", 60 - time_from);
            v28 = TTF_RenderText_Blended(font, time_text, 0xFFFFFFFFLL);
            if ( !v28 )
              break;
            v27 = SDL_CreateTextureFromSurface(renderer, v28);
            SDL_FreeSurface(v28);
            if ( !v27 )
              break;
            time_rect.x = 90;
            time_rect.y = 15;
            time_rect.w = v28->pitch;
            time_rect.h = *(&v28->pitch + 1);
            SDL_RenderCopy(renderer, v27, 0LL, (__int64)&time_rect);
            SDL_DestroyTexture(v27);
          }
          if ( TextureFromSurface && !counter_finished )
            SDL_RenderCopy(renderer, TextureFromSurface, 0LL, (__int64)&dst_rect);
          SDL_RenderPresent(renderer);
        }
        SDL_StopTextInput();
        if ( enter_pw_umgae )
          SDL_DestroyTexture(enter_pw_umgae);
        if ( qword_558900142200 )
          SDL_DestroyTexture(qword_558900142200);
        if ( final_render )
          SDL_DestroyTexture(final_render);
        if ( sound_image1 )
          SDL_DestroyTexture(sound_image1);
        if ( sound_image2 )
          SDL_DestroyTexture(sound_image2);
        if ( font )
          TTF_CloseFont(font);
        if ( renderer )
          SDL_DestroyRenderer(renderer);
        if ( window )
          SDL_DestroyWindow(window);
        sub_5588FFED97C4(qword_558900142240);
        TTF_Quit();
        SDL_Quit();
        return 0;
      }
      else
      {
        return 1;
      }
    }
    else
    {
      TTF_Quit();
      SDL_Quit();
      return 1;
    }
  }
}
// 5588FFEE1110: variable 'v3' is possibly undefined
// 5588FFEE1130: variable 'v4' is possibly undefined
// 5588FFED9070: using guessed type __int64 SDL_GetClipboardText(void);
// 5588FFED90D0: using guessed type __int64 __fastcall SDL_PauseAudioDevice(_QWORD, _QWORD);
// 5588FFED90F0: using guessed type __int64 SDL_Quit(void);
// 5588FFED9100: using guessed type __int64 __fastcall SDL_FreeSurface(_QWORD);
// 5588FFED9110: using guessed type __int64 __fastcall SDL_CreateRenderer(_QWORD, _QWORD, _QWORD);
// 5588FFED9130: using guessed type __int64 __fastcall SDL_CreateWindow(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 5588FFED91C0: using guessed type __int64 __fastcall TTF_CloseFont(_QWORD);
// 5588FFED91D0: using guessed type __int64 __fastcall SDL_DestroyWindow(_QWORD);
// 5588FFED91F0: using guessed type __int64 __fastcall SDL_DestroyRenderer(_QWORD);
// 5588FFED9200: using guessed type __int64 SDL_StopTextInput(void);
// 5588FFED9250: using guessed type __int64 __fastcall SDL_RenderClear(_QWORD);
// 5588FFED9260: using guessed type __int64 __fastcall SDL_CreateTextureFromSurface(_QWORD, _QWORD);
// 5588FFED9280: using guessed type __int64 __fastcall SDL_DestroyTexture(_QWORD);
// 5588FFED92B0: using guessed type __int64 __fastcall SDL_OpenAudioDevice(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 5588FFED92F0: using guessed type __int64 __fastcall SDL_SetRenderDrawColor(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 5588FFED9300: using guessed type __int64 __fastcall SDL_RenderPresent(_QWORD);
// 5588FFED9330: using guessed type __int64 TTF_Quit(void);
// 5588FFED9360: using guessed type __int64 __fastcall SDL_PollEvent(_QWORD);
// 5588FFED9380: using guessed type __int64 __fastcall SDL_GetTicks(_QWORD, _QWORD);
// 5588FFED93B0: using guessed type __int64 __fastcall SDL_free(_QWORD);
// 5588FFED93E0: using guessed type __int64 __fastcall SDL_Init(_QWORD, _QWORD, _QWORD);
// 5588FFED97C4: using guessed type __int64 __fastcall sub_5588FFED97C4(_QWORD);
// 5589001421E0: using guessed type __int64 window;
// 5589001421F0: using guessed type __int64 enter_pw_umgae;
// 5589001421F8: using guessed type __int64 final_render;
// 558900142200: using guessed type __int64 qword_558900142200;
// 558900142210: using guessed type int dword_558900142210;
// 558900142240: using guessed type __int64 qword_558900142240;
// 558900142248: using guessed type __int64 sound_image1;
// 558900142250: using guessed type __int64 sound_image2;
// 558900142360: using guessed type __int64 user_input_length;
// 558900142368: using guessed type int dword_558900142368;
// 55890014236C: using guessed type int counter_finished;
// 558900142370: using guessed type int ticks;
// 558900142374: using guessed type int dword_558900142374;
// 5588FFEE10E2: using guessed type int var_D0[3];
// 5588FFEE10E2: using guessed type char time_text[8];

//----- (00005588FFEE1B88) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=268 queued=140 decompiled=140 lumina nreq=0 worse=0 better=0
// ALL OK, 140 function(s) have been successfully decompiled
